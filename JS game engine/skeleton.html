<!-- A basic 2D HTML + JavaScript game engine, consisting of:
1. Canvas element, 800x600
2. Render loop
3. Update loop
4. Global data for current mouse position, stored as vector class
 -->

<!DOCTYPE html>
<html>
<head>
	<title>Game Engine</title>
	<style type="text/css">
		canvas {
			border: 1px solid black;
		}
	</style>
	<script type="text/javascript" src="GPTEngine.js"></script>
	<script type="text/javascript" src="Vector2D.js"></script>
    <script type="text/javascript" src="GameEntity.js"></script>
	<script type="text/javascript" src="Sprite.js"></script>
	<script type="text/javascript" src="Alien.js"></script>
	<script type="text/javascript" src="Shot.js"></script>
	<script type="text/javascript" src="Player.js"></script>
</head>
<body>
	<canvas id="gameCanvas" width="800" height="600"></canvas>
	<script type="text/javascript">
		const canvasName = "gameCanvas";
		// Get the canvas element
		const canvas = document.getElementById(canvasName);
		// Get the 2D context
		const context = canvas.getContext("2d");
		
		const engine = GPTEngine.begin(document, canvasName);
		Sprite.begin(context);
		
		const alienSize = 48;
		const alienSpeed = 1000/1000.0; // pixels per millisecond
		let backgroundSprite;
		let aliens = [];
		let alienDelayMilliseconds = 500;
		let lastAlienTime = Date.now();
		let shots = [];
		let shotDelayMilliseconds = 500;
		let lastShotTime = Date.now();
		(async () => {
			await Sprite.preloadSprites(
				['background.png', 'player-ship.png', 'alien-ship.png', 'energy-blast.png']
				);
		})();
		
		backgroundSprite = new Sprite(
			'background.png',
			new Vector2D(0, 0),
			new Vector2D(canvas.width, canvas.height)
		);
		let player = new Player();

		function loading() {
			return Sprite.stillLoading();
		}

		// AABB collision detection
		function checkCollision(entity1, entity2) {
			const pos1 = entity1.sprite.position;
			const size1 = entity1.sprite.size;
			const pos2 = entity2.sprite.position;
			const size2 = entity2.sprite.size;

			// AABB collision: check if rectangles overlap
			return (
				pos1.x - size1.x/2 < pos2.x + size2.x/2 &&
				pos1.x + size1.x/2 > pos2.x - size2.x/2 &&
				pos1.y - size1.y/2 < pos2.y + size2.y/2 &&
				pos1.y + size1.y/2 > pos2.y - size2.y/2
			);
		}
		
		// Render loop
		function render() {
			if (loading()) { return; }
			
			context.save();
			context.translate(
				canvas.width/2-player.sprite.position.x,
				canvas.height/2-player.sprite.position.y
			);
			
			backgroundSprite.draw();
			
			player.draw();
			
			for (const alien of aliens) {
				alien.draw();
			}
			for (const shot of shots) {
				shot.draw();
			}
			
			context.restore();
		}
		
		// Update loop; deltaTime is milliseconds
		function update(deltaTime) {
			if (loading()) { return; }
			
			if (engine.keyDown["ArrowLeft"]) {
				player.turnLeft(deltaTime);
			}
			if (engine.keyDown["ArrowRight"]) {
				player.turnRight(deltaTime);
			}
			if (engine.keyDown["ArrowUp"]) {
				player.accelerate(deltaTime);
			}
			if (engine.keyDown["ArrowDown"]) {
				player.reverseThrust(deltaTime);
			}
			if (engine.keyDown[" "]) {
				if (Date.now() > lastShotTime + shotDelayMilliseconds) {
					lastShotTime = Date.now();
					const shotVelocity = Vector2D.fromRadial(player.sprite.rotation, Shot.speed);
					const newShot = new Shot(
						new Vector2D(
							player.sprite.position.x,
							player.sprite.position.y
						),
						shotVelocity
					);
					shots.push(newShot);
				}
			}
			
			player.update(deltaTime);
			
			// Toggle fullscreen on ESC key
			if (engine.keyDown["Escape"]) {
				engine.keyDown["Escape"] = false;
				GPTEngine.instance.toggleFullScreen();
			}
			
			if (Date.now() > lastAlienTime + alienDelayMilliseconds) {
				lastAlienTime = Date.now();
				const newAlien = new Alien(
					new Vector2D(
						Alien.size.x/2 + (Math.random() * (canvas.width - Alien.size.x)),
						-Alien.size.y
					)
				);
				aliens.push(newAlien);
			}
			
			for (const alien of aliens) {
				alien.sprite.position.y += alienSpeed;
				alien.sprite.rotation += 0.02;
			}
			for (const shot of shots) {
				shot.update();
			}

			// Collision detection
			const aliensToRemove = new Set();
			const shotsToRemove = new Set();

			// Check shot-alien collisions
			for (const shot of shots) {
				for (const alien of aliens) {
					if (checkCollision(shot, alien)) {
						aliensToRemove.add(alien);
						shotsToRemove.add(shot);
					}
				}
			}

			// Check player-alien collisions
			for (const alien of aliens) {
				if (checkCollision(player, alien)) {
					aliensToRemove.add(alien);
					player.health -= alien.health; // Damage player by alien's health value
					console.log(`Player hit! Health: ${player.health}`);
				}
			}

			// Remove collided entities
			aliens = aliens.filter(alien => !aliensToRemove.has(alien));
			shots = shots.filter(shot => !shotsToRemove.has(shot));

			// Remove entities that are too far from player (avoid memory leak)
			const despawnDistance = Math.max(canvas.width, canvas.height) * 2;
			aliens = aliens.filter(alien => {
				const distance = alien.sprite.position.dist(player.sprite.position);
				return distance < despawnDistance;
			});
			shots = shots.filter(shot => {
				const distance = shot.sprite.position.dist(player.sprite.position);
				return distance < despawnDistance;
			});

			checkGamepadInput(deltaTime);
		}

		function checkGamepadInput(deltaTime) {
			const gamepads = navigator.getGamepads();
			const deadzone = 0.15; // Ignore small stick movements to prevent drift

			for (const gamepad of gamepads) {
				if (!gamepad) continue;

				// Left stick horizontal (axis 0): Turn left/right
				const leftStickX = gamepad.axes[0];
				if (Math.abs(leftStickX) > deadzone) {
					if (leftStickX < 0) {
						player.turnLeft(deltaTime * Math.abs(leftStickX));
					} else {
						player.turnRight(deltaTime * leftStickX);
					}
				}

				// Right stick vertical (axis 3) or triggers for thrust
				const rightStickY = gamepad.axes[3];
				if (rightStickY < -deadzone) {
					// Right stick pushed up: forward thrust
					player.accelerate(deltaTime * Math.abs(rightStickY));
				} else if (rightStickY > deadzone) {
					// Right stick pulled down: reverse thrust
					player.reverseThrust(deltaTime * rightStickY);
				}

				// Button 7 (RT/R2): Forward thrust
				if (gamepad.buttons[7] && gamepad.buttons[7].pressed) {
					const triggerValue = gamepad.buttons[7].value || 1.0;
					player.accelerate(deltaTime * triggerValue);
				}

				// Button 6 (LT/L2): Reverse thrust
				if (gamepad.buttons[6] && gamepad.buttons[6].pressed) {
					const triggerValue = gamepad.buttons[6].value || 1.0;
					player.reverseThrust(deltaTime * triggerValue);
				}

				// Button 0 (A/Cross): Shoot
				if (gamepad.buttons[0] && gamepad.buttons[0].pressed) {
					if (Date.now() > lastShotTime + shotDelayMilliseconds) {
						lastShotTime = Date.now();
						const shotVelocity = Vector2D.fromRadial(player.sprite.rotation, Shot.speed);
						const newShot = new Shot(
							new Vector2D(
								player.sprite.position.x,
								player.sprite.position.y
							),
							shotVelocity
						);
						shots.push(newShot);
					}
				}

				// Button 9 (Start/Options): Toggle fullscreen
				if (gamepad.buttons[9] && gamepad.buttons[9].pressed) {
					// Debounce by checking if button was just pressed
					if (!gamepad.buttons[9].wasPressed) {
						GPTEngine.instance.toggleFullScreen();
						gamepad.buttons[9].wasPressed = true;
					}
				} else if (gamepad.buttons[9]) {
					gamepad.buttons[9].wasPressed = false;
				}
			}
		}
		
		// Game loop
		var lastCallTime = Date.now();
		function loop() {
			var currentTime = Date.now();
			var deltaTime = currentTime - lastCallTime;
			lastCallTime = currentTime;
			update(deltaTime);
			render();
			// Call the loop function again
			window.requestAnimationFrame(loop);
		}
		
		// Call the loop function for the first time
		loop();
	</script>
</body>
</html>