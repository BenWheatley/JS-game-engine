<!-- A basic 2D HTML + JavaScript game engine, consisting of:
1. Canvas element, 800x600
2. Render loop
3. Update loop
4. Global data for current mouse position, stored as vector class
 -->

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Game Engine</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link id="css" rel="stylesheet" href="css.css"/ >
	<script type="text/javascript" src="GameConfig.js"></script>
	<script type="text/javascript" src="GPTEngine.js"></script>
	<script type="text/javascript" src="Vector2D.js"></script>
	<script type="text/javascript" src="NPCAIUtils.js"></script>
    <script type="text/javascript" src="GameEntity.js"></script>
	<script type="text/javascript" src="Sprite.js"></script>
	<script type="text/javascript" src="NPC.js"></script>
	<script type="text/javascript" src="AlienScout.js"></script>
	<script type="text/javascript" src="AlienFighter.js"></script>
	<script type="text/javascript" src="Asteroid.js"></script>
	<script type="text/javascript" src="AsteroidSpawn.js"></script>
	<script type="text/javascript" src="Projectile.js"></script>
	<script type="text/javascript" src="Laser.js"></script>
	<script type="text/javascript" src="Plasma.js"></script>
	<script type="text/javascript" src="Missile.js"></script>
	<script type="text/javascript" src="MissileCruiser.js"></script>
	<script type="text/javascript" src="Player.js"></script>
	<script type="text/javascript" src="SoundManager.js"></script>
	<script type="text/javascript" src="SimpleMusic.js"></script>
	<script type="text/javascript" src="MusicPlayer.js"></script>
	<script type="text/javascript" src="MenuSystem.js"></script>
	<script type="text/javascript" src="Minimap.js"></script>
</head>
<body>
	<div id="gameContainer">
		<canvas id="gameCanvas" width="800" height="600"></canvas>
		<div id="menuOverlay">
			<div class="menu-title" id="menuTitle">
				<img id="menuTitleImage" src="title.png" alt="SPACE SHOOTER" style="width: 325px; height: 28px;">
			</div>
			<div class="menu-buttons" id="menuButtons"></div>
			<div class="menu-instructions" id="menuInstructions"></div>
		</div>
	</div>
	<script type="text/javascript">
		const canvasName = "gameCanvas";
		// Get the canvas element
		const canvas = document.getElementById(canvasName);
		// Get the 2D context
		const context = canvas.getContext("2d");
		
		const engine = GPTEngine.begin(document, canvasName);
		Sprite.begin(context);

		// Initialize menu system
		const menuSystem = new MenuSystem(
			document.getElementById('menuOverlay'),
			document.getElementById('menuTitle'),
			document.getElementById('menuButtons'),
			document.getElementById('menuInstructions')
		);

		// Preferences Management
		function getPreferences() {
			const stored = localStorage.getItem('preferences');
			if (stored) {
				return JSON.parse(stored);
			}
			// Default preferences
			return {
				volume_effects: 100,
				volume_music: 100
			};
		}

		function savePreferences(preferences) {
			localStorage.setItem('preferences', JSON.stringify(preferences));
		}

		// Game state management
		const GameState = {
			MENU: 'menu',
			PLAYING: 'playing',
			PAUSED: 'paused',
			GAME_OVER: 'game_over'
		};
		let currentState = GameState.MENU;
		let score = 0;

		// Audio settings - load from preferences
		const preferences = getPreferences();
		let soundEffectsVolume = preferences.volume_effects;
		let musicVolume = preferences.volume_music;

		// Helper function to apply volume
		function playSoundEffect(name, baseVolume) {
			soundManager.play(name, baseVolume * (soundEffectsVolume / 100));
		}

		const alienSize = 48;
		const alienSpeed = 1000/1000.0; // pixels per millisecond
		let backgroundSprite;
		let aliens = [];
		let alienScouts = [];
		let alienFighters = [];
		let alienFighterShots = []; // Shots fired by alien fighters
		let missileCruisers = [];
		let cruiserMissiles = []; // Missiles fired by missile cruisers
		let asteroids = [];
		let asteroidSpawns = []; // Smaller asteroids spawned from destroyed asteroids
		let shots = [];
		let lastShotTime = 0; // Changed to use gameTime instead of Date.now()

		// Wave-based spawning
		let currentLevel = 1;

		// Game time tracking (accumulated deltaTime, doesn't advance when paused)
		let gameTime = 0;

		// Initialize sound manager and music player
		const soundManager = SoundManager.init();
		const musicPlayer = new MusicPlayer();

		// Preload assets
		(async () => {
			await Sprite.preloadSprites(
				['background.png', 'title.png', 'player-ship.png', 'alien-ship.png', 'alien-scout.png', 'alien-fighter.png', 'missile_ship.png', 'asteroid-big.png', 'asteroid-medium.png', 'asteroid-small.png', 'laser.png', 'plasma.png', 'missile.png']
			);
			await soundManager.loadSounds({
				'shoot': 'laser_1.2.m4a',
				'explosion': 'explosion_medium.m4a',
				'hit': 'explosion_small.m4a',
				'missile_launcher': 'missile_launcher.m4a'
			});
			await musicPlayer.loadMusic('slow_guitar.json');

			// Initialize music volume after Note class is available
			Note.setVolume(musicVolume / 100);
		})();

		// Background will be tiled - store a single tile sprite
		let backgroundTileSize = new Vector2D(1536, 1024); // Actual size of background image
		backgroundSprite = new Sprite(
			'background.png',
			new Vector2D(0, 0),
			backgroundTileSize
		);
		let player = new Player();
		let minimap = new Minimap(canvas.width, canvas.height);

		function loading() {
			return Sprite.stillLoading();
		}

		// AABB collision detection
		function checkCollision(entity1, entity2) {
			const pos1 = entity1.sprite.position;
			const size1 = entity1.sprite.size;
			const pos2 = entity2.sprite.position;
			const size2 = entity2.sprite.size;

			// AABB collision: check if rectangles overlap
			return (
				pos1.x - size1.x/2 < pos2.x + size2.x/2 &&
				pos1.x + size1.x/2 > pos2.x - size2.x/2 &&
				pos1.y - size1.y/2 < pos2.y + size2.y/2 &&
				pos1.y + size1.y/2 > pos2.y - size2.y/2
			);
		}

		// Game state management functions
		function startGame() {
			resetGame();
			currentState = GameState.PLAYING;
			menuSystem.hideMenu();
			musicPlayer.play();
			canvas.classList.add('hide-cursor');
		}

		function resetGame() {
			player = new Player();
			aliens = [];
			alienScouts = [];
			alienFighters = [];
			alienFighterShots = [];
			missileCruisers = [];
			cruiserMissiles = [];
			asteroids = [];
			asteroidSpawns = [];
			shots = [];
			score = 0;
			lastShotTime = 0; // Reset to gameTime zero
			gameTime = 0; // Reset game time
			currentLevel = 1;
			spawnWave(currentLevel); // Spawn first wave
		}

		// Wave spawning system
		function countNPCs() {
			return alienScouts.length +
			       alienFighters.length +
			       missileCruisers.length +
			       asteroids.length +
			       asteroidSpawns.length;
		}

		function getWaveDefinition(level) {
			const waveIndex = Math.min(level - 1, GameConfig.SPAWNING.MAX_LEVEL_INDEX);
			const baseWave = GameConfig.SPAWNING.WAVES[waveIndex];

			// If level exceeds wave definitions, scale up the last wave
			if (level > GameConfig.SPAWNING.WAVES.length) {
				const levelsOver = level - GameConfig.SPAWNING.WAVES.length;
				const scaleFactor = Math.pow(GameConfig.SPAWNING.SCALING_FACTOR, levelsOver);
				return {
					alienScouts: Math.floor(baseWave.alienScouts * scaleFactor),
					alienFighters: Math.floor(baseWave.alienFighters * scaleFactor),
					missileCruisers: Math.floor(baseWave.missileCruisers * scaleFactor),
					asteroids: Math.floor(baseWave.asteroids * scaleFactor)
				};
			}

			return baseWave;
		}

		function getOffscreenSpawnPosition(playerPos, canvasWidth, canvasHeight) {
			// Get random angle around player
			const angle = Math.random() * Math.PI * 2;

			// Get random distance (on minimap but outside screen)
			const minDist = GameConfig.SPAWNING.SPAWN_MIN_DISTANCE;
			const maxDist = GameConfig.SPAWNING.SPAWN_MAX_DISTANCE;
			const distance = minDist + Math.random() * (maxDist - minDist);

			// Calculate position
			return new Vector2D(
				playerPos.x + Math.cos(angle) * distance,
				playerPos.y + Math.sin(angle) * distance
			);
		}

		function spawnWave(level) {
			const wave = getWaveDefinition(level);
			const playerPos = player.sprite.position;

			console.log(`Spawning Wave ${level}:`, wave);

			// Spawn alien scouts
			for (let i = 0; i < wave.alienScouts; i++) {
				const position = getOffscreenSpawnPosition(playerPos, canvas.width, canvas.height);
				const scout = new AlienScout(playerPos, canvas.width, canvas.height);
				scout.sprite.position = position;
				alienScouts.push(scout);
			}

			// Spawn alien fighters
			for (let i = 0; i < wave.alienFighters; i++) {
				const position = getOffscreenSpawnPosition(playerPos, canvas.width, canvas.height);
				const fighter = new AlienFighter(playerPos, canvas.width, canvas.height);
				fighter.sprite.position = position;
				alienFighters.push(fighter);
			}

			// Spawn missile cruisers
			for (let i = 0; i < wave.missileCruisers; i++) {
				const position = getOffscreenSpawnPosition(playerPos, canvas.width, canvas.height);
				const cruiser = new MissileCruiser(playerPos, canvas.width, canvas.height);
				cruiser.sprite.position = position;
				missileCruisers.push(cruiser);
			}

			// Spawn asteroids
			for (let i = 0; i < wave.asteroids; i++) {
				const position = getOffscreenSpawnPosition(playerPos, canvas.width, canvas.height);
				const asteroid = new Asteroid(playerPos, canvas.width, canvas.height);
				asteroid.sprite.position = position;
				asteroids.push(asteroid);
			}
		}

		function gameOver() {
			currentState = GameState.GAME_OVER;
			musicPlayer.stop();
			canvas.classList.remove('hide-cursor');
			showGameOverMenu();
		}

		function returnToMenu() {
			currentState = GameState.MENU;
			musicPlayer.stop();
			canvas.classList.remove('hide-cursor');
			showMainMenu();
		}

		// Menu configuration functions
		function showMainMenu() {
			// Remove pause class (show background image)
			document.getElementById('menuOverlay').classList.remove('pause');

			// Restore title image if it was replaced by text
			const titleElement = document.getElementById('menuTitle');
			if (!titleElement.querySelector('img')) {
				titleElement.innerHTML = '<img id="menuTitleImage" src="title.png" alt="SPACE SHOOTER" style="width: 325px; height: 28px;">';
			}

			menuSystem.showMenu({
				title: 'SPACE SHOOTER',
				items: [
					{
						type: 'button',
						label: 'New Game',
						action: () => startGame()
					},
					{
						type: 'button',
						label: 'High Scores',
						action: () => showHighScoresMenu()
					},
					{
						type: 'button',
						label: 'Options',
						action: () => showOptionsMenu()
					},
					{
						type: 'button',
						label: 'Achievements',
						action: () => alert('Achievements - Coming Soon!')
					}
				],
				instructions: 'Arrow Keys or Left Stick: Move | Space or A Button: Shoot | ESC: Pause'
			});
		}

		// High Score Management
		/**
		 * Sanitizes user input to prevent XSS attacks
		 * Removes HTML tags and dangerous characters while supporting international names
		 * Allows Unicode letters (all languages), numbers, spaces, and safe punctuation
		 * @param {string} input - Raw user input
		 * @returns {string} Sanitized string safe for display
		 */
		function sanitizeInput(input) {
			if (!input) return '';

			// Convert to string and trim
			let sanitized = String(input).trim();

			// Remove any HTML tags
			sanitized = sanitized.replace(/<[^>]*>/g, '');

			// As this is all local, I don't care about "dangerous Unicode ranges" where "danger" is limited to spoofing

			// Remove remaining angle brackets to prevent any HTML/script injection
			sanitized = sanitized.replace(/[<>]/g, '');

			// Allow: Unicode letters (\p{L}), numbers (\p{N}), combining marks (\p{M} for accents),
			// spaces, and safe punctuation (.-_')
			// This supports names in Chinese (中文), Japanese (日本語), Arabic (العربية),
			// Hindi (हिन्दी), Cyrillic (Русский), Greek (Ελληνικά), etc.
			sanitized = sanitized.replace(/[^\p{L}\p{N}\p{M}\s.\-_']/gu, '');

			// Limit consecutive spaces to single space
			sanitized = sanitized.replace(/\s+/g, ' ');

			// Trim again after replacements
			sanitized = sanitized.trim();

			return sanitized;
		}

		function getHighScores() {
			const stored = localStorage.getItem('highScores');
			if (!stored) return [];

			const scores = JSON.parse(stored);
			// Sanitize all names when loading (defense against legacy data)
			return scores.map(score => ({
				...score,
				name: sanitizeInput(score.name)
			}));
		}

		function saveHighScore(name, score) {
			const highScores = getHighScores();

			// Sanitize the name to prevent XSS
			const sanitizedName = sanitizeInput(name);

			const newScore = {
				name: sanitizedName,
				score: score,
				date: new Date().toISOString()
			};
			highScores.push(newScore);

			// Sort by score descending
			highScores.sort((a, b) => b.score - a.score);

			// Keep only top 100 to prevent unlimited growth
			const top100 = highScores.slice(0, 100);
			localStorage.setItem('highScores', JSON.stringify(top100));
		}

		function showHighScoresMenu() {
			// Remove pause class (show background image)
			document.getElementById('menuOverlay').classList.remove('pause');

			const allScores = getHighScores();

			// Find the most recent score by date
			let mostRecentScore = null;
			let mostRecentDate = null;

			allScores.forEach(score => {
				const scoreDate = new Date(score.date);
				if (!mostRecentDate || scoreDate > mostRecentDate) {
					mostRecentDate = scoreDate;
					mostRecentScore = score;
				}
			});

			// Find the rank of the most recent score
			const recentIndex = mostRecentScore ? allScores.indexOf(mostRecentScore) : -1;
			const recentRank = recentIndex >= 0 ? recentIndex + 1 : -1;

			let displayScores = [];

			if (recentRank === -1 || recentRank <= 10) {
				// Recent score is in top 10 or doesn't exist, show top 10 normally
				displayScores = allScores.slice(0, 10).map((score, index) => ({
					...score,
					rank: index + 1,
					isEllipsis: false,
					isRecent: score === mostRecentScore
				}));
			} else {
				// Recent score is outside top 10
				// Show positions 1-8
				displayScores = allScores.slice(0, 8).map((score, index) => ({
					...score,
					rank: index + 1,
					isEllipsis: false,
					isRecent: score === mostRecentScore
				}));

				// Add ellipsis at position 9
				displayScores.push({
					isEllipsis: true,
					rank: 9
				});

				// Add recent score at position 10 with its actual rank
				displayScores.push({
					...allScores[recentIndex],
					rank: recentRank,
					isEllipsis: false,
					isRecent: true
				});
			}

			menuSystem.showMenu({
				title: 'HIGH SCORES',
				items: [
					{
						type: 'scoreList',
						scores: displayScores
					},
					{
						type: 'button',
						label: 'Back',
						action: () => showMainMenu()
					}
				]
			});
		}

		function showGameOverMenu() {
			// Remove pause class (show background image)
			document.getElementById('menuOverlay').classList.remove('pause');

			let playerName = '';

			menuSystem.showMenu({
				title: 'GAME OVER',
				items: [
					{
						type: 'textInput',
						id: 'playerNameInput',
						label: 'Enter Your Name:',
						placeholder: 'Player',
						maxLength: 15,
						autofocus: true,
						onChange: (value) => {
							// Sanitize input in real-time to prevent XSS
							playerName = sanitizeInput(value);
							// Update the input field with sanitized value
							const input = document.getElementById('playerNameInput');
							if (input && input.value !== playerName) {
								input.value = playerName;
							}
						}
					},
					{
						type: 'button',
						label: 'Submit Score',
						action: () => {
							const name = playerName.trim() || 'Anonymous';
							saveHighScore(name, score);
							showHighScoresMenu();
						}
					},
					{
						type: 'button',
						label: 'New Game',
						action: () => {
							const name = playerName.trim() || 'Anonymous';
							saveHighScore(name, score);
							startGame();
						}
					},
					{
						type: 'button',
						label: 'Main Menu',
						action: () => {
							const name = playerName.trim() || 'Anonymous';
							saveHighScore(name, score);
							returnToMenu();
						}
					}
				],
				instructions: `Final Score: ${score}`
			});
		}

		function pauseGame() {
			if (currentState === GameState.PLAYING) {
				currentState = GameState.PAUSED;
				musicPlayer.pause();
				canvas.classList.remove('hide-cursor');
				showPauseMenu();
			}
		}

		function resumeGame() {
			currentState = GameState.PLAYING;
			menuSystem.hideMenu();
			musicPlayer.play();
			canvas.classList.add('hide-cursor');
		}

		function showPauseMenu() {
			// Add pause class for transparent overlay (no background image)
			document.getElementById('menuOverlay').classList.add('pause');

			menuSystem.showMenu({
				title: 'PAUSED',
				items: [
					{
						type: 'button',
						label: 'Continue',
						action: () => resumeGame()
					},
					{
						type: 'slider',
						label: 'Sound Effects Volume',
						min: 0,
						max: 100,
						value: soundEffectsVolume,
						suffix: '%',
						onChange: (value) => {
							soundEffectsVolume = parseInt(value);
							const prefs = getPreferences();
							prefs.volume_effects = soundEffectsVolume;
							savePreferences(prefs);
						}
					},
					{
						type: 'slider',
						label: 'Music Volume',
						min: 0,
						max: 100,
						value: musicVolume,
						suffix: '%',
						onChange: (value) => {
							musicVolume = parseInt(value);
							Note.setVolume(musicVolume / 100); // Convert percentage to 0.0-1.0
							const prefs = getPreferences();
							prefs.volume_music = musicVolume;
							savePreferences(prefs);
						}
					},
					{
						type: 'checkbox',
						label: 'Fullscreen',
						checked: GPTEngine.instance.isFullScreen,
						onChange: (checked) => {
							if (checked && !GPTEngine.instance.isFullScreen) {
								GPTEngine.instance.enterFullScreen();
							} else if (!checked && GPTEngine.instance.isFullScreen) {
								GPTEngine.instance.exitFullScreen();
							}
						}
					},
					{
						type: 'button',
						label: 'Quit',
						action: () => {
							if (score > 0) {
								gameOver();
							} else {
								returnToMenu();
							}
						}
					}
				],
				instructions: ''
			});
		}

		function showOptionsMenu() {
			// Remove pause class (show background image)
			document.getElementById('menuOverlay').classList.remove('pause');

			menuSystem.showMenu({
				title: 'OPTIONS',
				items: [
					{
						type: 'slider',
						label: 'Sound Effects Volume',
						min: 0,
						max: 100,
						value: soundEffectsVolume,
						suffix: '%',
						onChange: (value) => {
							soundEffectsVolume = parseInt(value);
							const prefs = getPreferences();
							prefs.volume_effects = soundEffectsVolume;
							savePreferences(prefs);
						}
					},
					{
						type: 'slider',
						label: 'Music Volume',
						min: 0,
						max: 100,
						value: musicVolume,
						suffix: '%',
						onChange: (value) => {
							musicVolume = parseInt(value);
							Note.setVolume(musicVolume / 100); // Convert percentage to 0.0-1.0
							const prefs = getPreferences();
							prefs.volume_music = musicVolume;
							savePreferences(prefs);
						}
					},
					{
						type: 'checkbox',
						label: 'Fullscreen',
						checked: GPTEngine.instance.isFullScreen,
						onChange: (checked) => {
							if (checked && !GPTEngine.instance.isFullScreen) {
								GPTEngine.instance.enterFullScreen();
							} else if (!checked && GPTEngine.instance.isFullScreen) {
								GPTEngine.instance.exitFullScreen();
							}
						}
					},
					{
						type: 'button',
						label: 'Back',
						action: () => showMainMenu()
					}
				],
				instructions: ''
			});
		}

		// Render loop
		function render() {
			if (loading()) { return; }

			switch (currentState) {
				case GameState.MENU:
					renderMenu();
					break;
				case GameState.PLAYING:
					renderGame();
					break;
				case GameState.PAUSED:
					renderGame(); // Keep showing game behind pause menu
					break;
				case GameState.GAME_OVER:
					renderGameOver();
					break;
			}
		}

		function renderMenu() {
			// Clear screen - menu background is handled by CSS
			context.fillStyle = '#000000';
			context.fillRect(0, 0, canvas.width, canvas.height);
		}

		function renderGame() {
			context.save();
			context.translate(
				canvas.width/2-player.sprite.position.x,
				canvas.height/2-player.sprite.position.y
			);

			// Draw tiled background
			const tileWidth = backgroundTileSize.x;
			const tileHeight = backgroundTileSize.y;

			// Calculate which tiles are visible
			const startX = Math.floor((player.sprite.position.x - canvas.width) / tileWidth) * tileWidth;
			const startY = Math.floor((player.sprite.position.y - canvas.height) / tileHeight) * tileHeight;
			const endX = Math.ceil((player.sprite.position.x + canvas.width) / tileWidth) * tileWidth;
			const endY = Math.ceil((player.sprite.position.y + canvas.height) / tileHeight) * tileHeight;

			// Draw tiles
			for (let x = startX; x <= endX; x += tileWidth) {
				for (let y = startY; y <= endY; y += tileHeight) {
					backgroundSprite.position.x = x + tileWidth / 2;
					backgroundSprite.position.y = y + tileHeight / 2;
					backgroundSprite.draw();
				}
			}

			player.draw();

			for (const alien of aliens) {
				alien.draw();
			}
			for (const alienScout of alienScouts) {
				alienScout.draw();
			}
			for (const alienFighter of alienFighters) {
				alienFighter.draw();
			}
			for (const missileCruiser of missileCruisers) {
				missileCruiser.draw();
			}
			for (const asteroid of asteroids) {
				asteroid.draw();
			}
			for (const asteroidSpawn of asteroidSpawns) {
				asteroidSpawn.draw();
			}
			for (const shot of shots) {
				shot.draw();
			}
			for (const alienShot of alienFighterShots) {
				alienShot.draw();
			}
			for (const missile of cruiserMissiles) {
				missile.draw();
			}

			context.restore();

			// HUD - render in screen space
			// Health bar
			const healthBarWidth = GameConfig.HUD.HEALTH_BAR_WIDTH;
			const healthBarHeight = GameConfig.HUD.HEALTH_BAR_HEIGHT;
			const healthBarX = GameConfig.HUD.HEALTH_BAR_X;
			const healthBarY = GameConfig.HUD.HEALTH_BAR_Y;

			// Draw health bar background (red - shows damage)
			context.fillStyle = GameConfig.HUD.HEALTH_BAR_BG_COLOR;
			context.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

			// Draw health bar foreground (green - shows current health)
			const healthPercentage = Math.max(0, Math.min(1, player.health / player.maxHealth));
			const currentHealthWidth = healthBarWidth * healthPercentage;
			context.fillStyle = GameConfig.HUD.HEALTH_BAR_FG_COLOR;
			context.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

			// Draw health bar border (white)
			context.strokeStyle = GameConfig.HUD.HEALTH_BAR_BORDER_COLOR;
			context.lineWidth = GameConfig.HUD.HEALTH_BAR_BORDER_WIDTH;
			context.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

			// Draw score
			context.fillStyle = '#FFFFFF';
			context.font = '20px Arial';
			context.textAlign = 'left';
			context.fillText(`Score: ${score}`, 10, 60);

			// Mini-map
			minimap.draw(context, {
				asteroids: asteroids,
				asteroidSpawns: asteroidSpawns,
				aliens: aliens,
				alienScouts: alienScouts,
				alienFighters: alienFighters,
				missileCruisers: missileCruisers
			}, player.sprite.position);
		}

		function renderGameOver() {
			// Clear screen - menu background is handled by CSS
			context.fillStyle = '#000000';
			context.fillRect(0, 0, canvas.width, canvas.height);
		}
		
		// Update loop; deltaTime is milliseconds
		function update(deltaTime) {
			if (loading()) { return; }

			// Handle ESC key for pause/resume
			if (engine.keyDown["Escape"]) {
				engine.keyDown["Escape"] = false;
				if (currentState === GameState.PLAYING) {
					pauseGame();
				} else if (currentState === GameState.PAUSED) {
					resumeGame();
				}
			}

			switch (currentState) {
				case GameState.MENU:
					updateMenu();
					break;
				case GameState.PLAYING:
					updateGame(deltaTime);
					break;
				case GameState.PAUSED:
					// Don't update game state while paused
					break;
				case GameState.GAME_OVER:
					updateGameOver();
					break;
			}
		}

		function updateMenu() {
			// Menu is now HTML-based, no keyboard input needed
		}

		function updateGameOver() {
			// Game over menu is now HTML-based, no keyboard input needed
		}

		function updateGame(deltaTime) {
			// Accumulate game time (only advances during gameplay, not when paused)
			gameTime += deltaTime;

			if (engine.keyDown["ArrowLeft"]) {
				player.turnLeft(deltaTime);
			}
			if (engine.keyDown["ArrowRight"]) {
				player.turnRight(deltaTime);
			}
			if (engine.keyDown["ArrowUp"]) {
				player.accelerate(deltaTime);
			}
			if (engine.keyDown["ArrowDown"]) {
				player.reverseThrust(deltaTime);
			}
			if (engine.keyDown[" "]) {
				if (gameTime > lastShotTime + GameConfig.PLAYER.FIRE_RATE) {
					lastShotTime = gameTime;
					const shotVelocity = Vector2D.fromRadial(player.sprite.rotation, Laser.speed);
					const newShot = new Laser(
						new Vector2D(
							player.sprite.position.x,
							player.sprite.position.y
						),
						shotVelocity
					);
					shots.push(newShot);
					playSoundEffect('shoot', 0.3);
				}
			}

			player.update(deltaTime);

			for (const alienScout of alienScouts) {
				alienScout.update(deltaTime, player.sprite.position);
			}
			for (const alienFighter of alienFighters) {
				alienFighter.update(deltaTime, player.sprite.position);
				// Check if fighter wants to shoot
				const newShot = alienFighter.tryShoot(gameTime);
				if (newShot) {
					alienFighterShots.push(newShot);
					playSoundEffect('shoot', 0.2); // Quieter than player shots
				}
			}
			for (const missileCruiser of missileCruisers) {
				missileCruiser.update(deltaTime, player.sprite.position);
				// Check if cruiser wants to shoot
				const newMissile = missileCruiser.tryShoot(gameTime);
				if (newMissile) {
					cruiserMissiles.push(newMissile);
					playSoundEffect('missile_launcher', 0.3);
				}
			}
			for (const asteroid of asteroids) {
				asteroid.update(deltaTime);
			}
			for (const asteroidSpawn of asteroidSpawns) {
				asteroidSpawn.update(deltaTime);
			}
			for (const shot of shots) {
				shot.update();
			}
			for (const alienShot of alienFighterShots) {
				alienShot.update();
			}
			for (const missile of cruiserMissiles) {
				missile.update();
			}

			// Wave-based spawning: Check if all NPCs are cleared
			if (countNPCs() === 0) {
				currentLevel++;
				console.log(`Wave ${currentLevel - 1} cleared! Spawning wave ${currentLevel}`);
				spawnWave(currentLevel);
			}

			// Collision detection
			const aliensToRemove = new Set();
			const alienScoutsToRemove = new Set();
			const alienFightersToRemove = new Set();
			const missileCruisersToRemove = new Set();
			const shotsToRemove = new Set();
			const alienShotsToRemove = new Set();
			const missilesToRemove = new Set();

			// Check shot-alien collisions
			for (const shot of shots) {
				for (const alien of aliens) {
					if (checkCollision(shot, alien)) {
						aliensToRemove.add(alien);
						shotsToRemove.add(shot);
						score += 100; // Award points for destroying alien
						playSoundEffect('explosion', 0.5);
					}
				}
			}

			// Check shot-alienScout collisions
			for (const shot of shots) {
				for (const alienScout of alienScouts) {
					if (checkCollision(shot, alienScout)) {
						alienScoutsToRemove.add(alienScout);
						shotsToRemove.add(shot);
						score += 150; // Award points for destroying alien scout
						playSoundEffect('explosion', 0.5);
					}
				}
			}

			// Check shot-alienFighter collisions
			for (const shot of shots) {
				for (const alienFighter of alienFighters) {
					if (checkCollision(shot, alienFighter)) {
						alienFightersToRemove.add(alienFighter);
						shotsToRemove.add(shot);
						score += 200; // Award points for destroying alien fighter
						playSoundEffect('explosion', 0.5);
					}
				}
			}

			// Check shot-missileCruiser collisions
			for (const shot of shots) {
				for (const missileCruiser of missileCruisers) {
					if (checkCollision(shot, missileCruiser)) {
						shotsToRemove.add(shot);
						missileCruiser.health -= shot.damage;
						if (missileCruiser.health <= 0) {
							missileCruisersToRemove.add(missileCruiser);
							score += 300; // Award points for destroying missile cruiser
							playSoundEffect('explosion', 0.6);
						} else {
							playSoundEffect('hit', 0.4);
						}
					}
				}
			}

			// Check shot-asteroid collisions
			const asteroidsToRemove = new Set();
			for (const shot of shots) {
				for (const asteroid of asteroids) {
					if (checkCollision(shot, asteroid)) {
						shotsToRemove.add(shot);
						asteroid.health -= 1;
						if (asteroid.health <= 0) {
							asteroidsToRemove.add(asteroid);
							score += 200; // Award more points for destroying asteroid
							playSoundEffect('explosion', 0.5);
							// Spawn 3 smaller asteroids
							const spawns = AsteroidSpawn.createSpawnsFromAsteroid(asteroid, canvas.width, canvas.height);
							asteroidSpawns.push(...spawns);
						} else {
							playSoundEffect('hit', 0.4);
						}
					}
				}
			}

			// Check shot-asteroidSpawn collisions
			const asteroidSpawnsToRemove = new Set();
			for (const shot of shots) {
				for (const asteroidSpawn of asteroidSpawns) {
					if (checkCollision(shot, asteroidSpawn)) {
						shotsToRemove.add(shot);
						asteroidSpawnsToRemove.add(asteroidSpawn);
						score += 50; // Award points for destroying small asteroid
						playSoundEffect('explosion', 0.3);
					}
				}
			}

			// Check player-alien collisions
			for (const alien of aliens) {
				if (checkCollision(player, alien)) {
					aliensToRemove.add(alien);
					player.health -= alien.health; // Damage player by alien's health value
					console.log(`Player hit! Health: ${player.health}`);
					playSoundEffect('hit', 0.6);
				}
			}

			// Check player-alienScout collisions
			for (const alienScout of alienScouts) {
				if (checkCollision(player, alienScout)) {
					alienScoutsToRemove.add(alienScout);
					player.health -= alienScout.health; // Damage player by alien scout's health value
					console.log(`Player hit by alien scout! Health: ${player.health}`);
					playSoundEffect('hit', 0.6);
				}
			}

			// Check player-alienFighter collisions
			for (const alienFighter of alienFighters) {
				if (checkCollision(player, alienFighter)) {
					alienFightersToRemove.add(alienFighter);
					player.health -= alienFighter.health; // Damage player by alien fighter's health value
					console.log(`Player hit by alien fighter! Health: ${player.health}`);
					playSoundEffect('hit', 0.6);
				}
			}

			// Check player-missileCruiser collisions
			for (const missileCruiser of missileCruisers) {
				if (checkCollision(player, missileCruiser)) {
					missileCruisersToRemove.add(missileCruiser);
					player.health -= missileCruiser.health; // Damage player by missile cruiser's health value
					console.log(`Player hit by missile cruiser! Health: ${player.health}`);
					playSoundEffect('hit', 0.7);
				}
			}

			// Check player-asteroid collisions
			for (const asteroid of asteroids) {
				if (checkCollision(player, asteroid)) {
					asteroidsToRemove.add(asteroid);
					player.health -= 50; // Asteroids deal fixed damage
					console.log(`Player hit by asteroid! Health: ${player.health}`);
					playSoundEffect('hit', 0.6);
				}
			}

			// Check player-asteroidSpawn collisions
			for (const asteroidSpawn of asteroidSpawns) {
				if (checkCollision(player, asteroidSpawn)) {
					asteroidSpawnsToRemove.add(asteroidSpawn);
					player.health -= 25; // Small asteroids deal less damage
					console.log(`Player hit by small asteroid! Health: ${player.health}`);
					playSoundEffect('hit', 0.4);
				}
			}

			// Check alienFighterShots-player collisions
			for (const alienShot of alienFighterShots) {
				if (checkCollision(player, alienShot)) {
					alienShotsToRemove.add(alienShot);
					player.health -= 25; // Alien shots deal 25 damage
					console.log(`Player hit by alien shot! Health: ${player.health}`);
					playSoundEffect('hit', 0.5);
				}
			}

			// Check missile-player collisions
			for (const missile of cruiserMissiles) {
				if (checkCollision(player, missile)) {
					missilesToRemove.add(missile);
					player.health -= missile.damage; // Missiles deal 50 damage
					console.log(`Player hit by missile! Health: ${player.health}`);
					playSoundEffect('explosion', 0.6);
				}
			}

			// Remove collided entities
			aliens = aliens.filter(alien => !aliensToRemove.has(alien));
			alienScouts = alienScouts.filter(alienScout => !alienScoutsToRemove.has(alienScout));
			alienFighters = alienFighters.filter(alienFighter => !alienFightersToRemove.has(alienFighter));
			missileCruisers = missileCruisers.filter(missileCruiser => !missileCruisersToRemove.has(missileCruiser));
			asteroids = asteroids.filter(asteroid => !asteroidsToRemove.has(asteroid));
			asteroidSpawns = asteroidSpawns.filter(asteroidSpawn => !asteroidSpawnsToRemove.has(asteroidSpawn));
			shots = shots.filter(shot => !shotsToRemove.has(shot));
			alienFighterShots = alienFighterShots.filter(alienShot => !alienShotsToRemove.has(alienShot));
			cruiserMissiles = cruiserMissiles.filter(missile => !missilesToRemove.has(missile));

			// Check for game over
			if (player.health <= 0) {
				gameOver();
				return;
			}

			// Wrap NPCs that go beyond minimap bounds, despawn projectiles
			const wrapDistance = GameConfig.WORLD.NPC_WRAP_DISTANCE; // Minimap range - wrap NPCs at this distance
			const despawnDistance = Math.max(canvas.width, canvas.height) * GameConfig.WORLD.PROJECTILE_DESPAWN_MULTIPLIER; // Despawn projectiles

			// Wrap aliens around minimap edges
			for (const alien of aliens) {
				const offsetX = alien.sprite.position.x - player.sprite.position.x;
				const offsetY = alien.sprite.position.y - player.sprite.position.y;

				if (offsetX > wrapDistance) {
					alien.sprite.position.x = player.sprite.position.x - wrapDistance;
				} else if (offsetX < -wrapDistance) {
					alien.sprite.position.x = player.sprite.position.x + wrapDistance;
				}

				if (offsetY > wrapDistance) {
					alien.sprite.position.y = player.sprite.position.y - wrapDistance;
				} else if (offsetY < -wrapDistance) {
					alien.sprite.position.y = player.sprite.position.y + wrapDistance;
				}
			}

			// Wrap alien scouts around minimap edges
			for (const alienScout of alienScouts) {
				const offsetX = alienScout.sprite.position.x - player.sprite.position.x;
				const offsetY = alienScout.sprite.position.y - player.sprite.position.y;

				if (offsetX > wrapDistance) {
					alienScout.sprite.position.x = player.sprite.position.x - wrapDistance;
				} else if (offsetX < -wrapDistance) {
					alienScout.sprite.position.x = player.sprite.position.x + wrapDistance;
				}

				if (offsetY > wrapDistance) {
					alienScout.sprite.position.y = player.sprite.position.y - wrapDistance;
				} else if (offsetY < -wrapDistance) {
					alienScout.sprite.position.y = player.sprite.position.y + wrapDistance;
				}
			}

			// Wrap alien fighters around minimap edges
			for (const alienFighter of alienFighters) {
				const offsetX = alienFighter.sprite.position.x - player.sprite.position.x;
				const offsetY = alienFighter.sprite.position.y - player.sprite.position.y;

				if (offsetX > wrapDistance) {
					alienFighter.sprite.position.x = player.sprite.position.x - wrapDistance;
				} else if (offsetX < -wrapDistance) {
					alienFighter.sprite.position.x = player.sprite.position.x + wrapDistance;
				}

				if (offsetY > wrapDistance) {
					alienFighter.sprite.position.y = player.sprite.position.y - wrapDistance;
				} else if (offsetY < -wrapDistance) {
					alienFighter.sprite.position.y = player.sprite.position.y + wrapDistance;
				}
			}

			// Wrap missile cruisers around minimap edges
			for (const missileCruiser of missileCruisers) {
				const offsetX = missileCruiser.sprite.position.x - player.sprite.position.x;
				const offsetY = missileCruiser.sprite.position.y - player.sprite.position.y;

				if (offsetX > wrapDistance) {
					missileCruiser.sprite.position.x = player.sprite.position.x - wrapDistance;
				} else if (offsetX < -wrapDistance) {
					missileCruiser.sprite.position.x = player.sprite.position.x + wrapDistance;
				}

				if (offsetY > wrapDistance) {
					missileCruiser.sprite.position.y = player.sprite.position.y - wrapDistance;
				} else if (offsetY < -wrapDistance) {
					missileCruiser.sprite.position.y = player.sprite.position.y + wrapDistance;
				}
			}

			// Wrap asteroids around minimap edges
			for (const asteroid of asteroids) {
				const offsetX = asteroid.sprite.position.x - player.sprite.position.x;
				const offsetY = asteroid.sprite.position.y - player.sprite.position.y;

				if (offsetX > wrapDistance) {
					asteroid.sprite.position.x = player.sprite.position.x - wrapDistance;
				} else if (offsetX < -wrapDistance) {
					asteroid.sprite.position.x = player.sprite.position.x + wrapDistance;
				}

				if (offsetY > wrapDistance) {
					asteroid.sprite.position.y = player.sprite.position.y - wrapDistance;
				} else if (offsetY < -wrapDistance) {
					asteroid.sprite.position.y = player.sprite.position.y + wrapDistance;
				}
			}

			// Wrap asteroid spawns around minimap edges
			for (const asteroidSpawn of asteroidSpawns) {
				const offsetX = asteroidSpawn.sprite.position.x - player.sprite.position.x;
				const offsetY = asteroidSpawn.sprite.position.y - player.sprite.position.y;

				if (offsetX > wrapDistance) {
					asteroidSpawn.sprite.position.x = player.sprite.position.x - wrapDistance;
				} else if (offsetX < -wrapDistance) {
					asteroidSpawn.sprite.position.x = player.sprite.position.x + wrapDistance;
				}

				if (offsetY > wrapDistance) {
					asteroidSpawn.sprite.position.y = player.sprite.position.y - wrapDistance;
				} else if (offsetY < -wrapDistance) {
					asteroidSpawn.sprite.position.y = player.sprite.position.y + wrapDistance;
				}
			}
			shots = shots.filter(shot => {
				const distance = shot.sprite.position.dist(player.sprite.position);
				return distance < despawnDistance;
			});
			alienFighterShots = alienFighterShots.filter(alienShot => {
				const distance = alienShot.sprite.position.dist(player.sprite.position);
				return distance < despawnDistance;
			});
			cruiserMissiles = cruiserMissiles.filter(missile => {
				const distance = missile.sprite.position.dist(player.sprite.position);
				return distance < despawnDistance;
			});

			checkGamepadInput(deltaTime);
		}

		function checkGamepadInput(deltaTime) {
			const gamepads = navigator.getGamepads();
			const deadzone = GameConfig.PLAYER.GAMEPAD_DEADZONE; // Ignore small stick movements to prevent drift

			for (const gamepad of gamepads) {
				if (!gamepad) continue;

				// Left stick horizontal (axis 0): Turn left/right
				const leftStickX = gamepad.axes[0];
				if (Math.abs(leftStickX) > deadzone) {
					if (leftStickX < 0) {
						player.turnLeft(deltaTime * Math.abs(leftStickX));
					} else {
						player.turnRight(deltaTime * leftStickX);
					}
				}

				// Right stick vertical (axis 3) or triggers for thrust
				const rightStickY = gamepad.axes[3];
				if (rightStickY < -deadzone) {
					// Right stick pushed up: forward thrust
					player.accelerate(deltaTime * Math.abs(rightStickY));
				} else if (rightStickY > deadzone) {
					// Right stick pulled down: reverse thrust
					player.reverseThrust(deltaTime * rightStickY);
				}

				// Button 7 (RT/R2): Forward thrust
				if (gamepad.buttons[7] && gamepad.buttons[7].pressed) {
					const triggerValue = gamepad.buttons[7].value || 1.0;
					player.accelerate(deltaTime * triggerValue);
				}

				// Button 6 (LT/L2): Reverse thrust
				if (gamepad.buttons[6] && gamepad.buttons[6].pressed) {
					const triggerValue = gamepad.buttons[6].value || 1.0;
					player.reverseThrust(deltaTime * triggerValue);
				}

				// Button 0 (A/Cross): Shoot
				if (gamepad.buttons[0] && gamepad.buttons[0].pressed) {
					if (gameTime > lastShotTime + GameConfig.PLAYER.FIRE_RATE) {
						lastShotTime = gameTime;
						const shotVelocity = Vector2D.fromRadial(player.sprite.rotation, Laser.speed);
						const newShot = new Laser(
							new Vector2D(
								player.sprite.position.x,
								player.sprite.position.y
							),
							shotVelocity
						);
						shots.push(newShot);
						playSoundEffect('shoot', 0.3);
					}
				}

				// Button 9 (Start/Options): Pause game
				if (gamepad.buttons[9] && gamepad.buttons[9].pressed) {
					// Debounce by checking if button was just pressed
					if (!gamepad.buttons[9].wasPressed) {
						pauseGame();
						gamepad.buttons[9].wasPressed = true;
					}
				} else if (gamepad.buttons[9]) {
					gamepad.buttons[9].wasPressed = false;
				}
			}
		}
		
		// Game loop
		var lastCallTime = Date.now();
		function loop() {
			var currentTime = Date.now();
			var deltaTime = currentTime - lastCallTime;
			lastCallTime = currentTime;
			update(deltaTime);
			render();
			// Call the loop function again
			window.requestAnimationFrame(loop);
		}

		// Show main menu and start game loop
		showMainMenu();
		loop();
	</script>
</body>
</html>