<!-- A basic 2D HTML + JavaScript game engine, consisting of:
1. Canvas element, 800x600
2. Render loop
3. Update loop
4. Global data for current mouse position, stored as vector class
 -->

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Game Engine</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link id="css" rel="stylesheet" href="css.css"/ >
	<script type="text/javascript" src="DebugLogger.js"></script>
	<script>
		// Enable debug logging only when running on localhost
		DebugLogger.debug = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
	</script>
	<script type="text/javascript" src="GameConfig.js"></script>
	<script type="text/javascript" src="AssetLoader.js"></script>
	<script type="text/javascript" src="CollisionDetection.js"></script>
	<script type="text/javascript" src="VibeEngine.js"></script>
	<script type="text/javascript" src="Vector2D.js"></script>
	<script type="text/javascript" src="Particle.js"></script>
	<script type="text/javascript" src="ParticleSystem.js"></script>
	<script type="text/javascript" src="NPCAIUtils.js"></script>
	<script type="text/javascript" src="SpawnSystem.js"></script>
	<script type="text/javascript" src="GameState.js"></script>
    <script type="text/javascript" src="GameEntity.js"></script>
	<script type="text/javascript" src="Sprite.js"></script>
	<script type="text/javascript" src="NPC.js"></script>
	<script type="text/javascript" src="AlienScout.js"></script>
	<script type="text/javascript" src="AlienFighter.js"></script>
	<script type="text/javascript" src="Asteroid.js"></script>
	<script type="text/javascript" src="AsteroidSpawn.js"></script>
	<script type="text/javascript" src="Wormhole.js"></script>
	<script type="text/javascript" src="UpgradeBackground.js"></script>
	<script type="text/javascript" src="Projectile.js"></script>
	<script type="text/javascript" src="Laser.js"></script>
	<script type="text/javascript" src="Plasma.js"></script>
	<script type="text/javascript" src="Missile.js"></script>
	<script type="text/javascript" src="MissileCruiser.js"></script>
	<script type="text/javascript" src="AlienSaucer.js"></script>
	<script type="text/javascript" src="Player.js"></script>
	<script type="text/javascript" src="SoundManager.js"></script>
	<script type="text/javascript" src="SimpleMusic.js"></script>
	<script type="text/javascript" src="MusicPlayer.js"></script>
	<script type="text/javascript" src="MenuSystem.js"></script>
	<script type="text/javascript" src="PreferencesManager.js"></script>
	<script type="text/javascript" src="HighScoreManager.js"></script>
	<script type="text/javascript" src="AchievementManager.js"></script>
	<script type="text/javascript" src="Minimap.js"></script>
</head>
<body>
	<div id="gameContainer">
		<canvas id="gameCanvas" width="800" height="600"></canvas>
		<div id="menuOverlay">
			<div class="menu-title" id="menuTitle">
				<img id="menuTitleImage" src="title.png" alt="SPACE SHOOTER" style="width: 325px; height: 28px;">
			</div>
			<div class="menu-buttons" id="menuButtons"></div>
			<div class="menu-instructions" id="menuInstructions"></div>
		</div>
	</div>
	<script type="text/javascript">
		const canvasName = "gameCanvas";
		// Get the canvas element
		const canvas = document.getElementById(canvasName);
		// Get the 2D context
		const context = canvas.getContext("2d");
		
		const engine = VibeEngine.begin(document, canvasName);
		Sprite.begin(context);

		// Initialize menu system
		const menuSystem = new MenuSystem(
			document.getElementById('menuOverlay'),
			document.getElementById('menuTitle'),
			document.getElementById('menuButtons'),
			document.getElementById('menuInstructions')
		);

		// Initialize high score manager
		const highScoreManager = new HighScoreManager(menuSystem);

		// Initialize achievement manager
		const achievementManager = new AchievementManager(menuSystem);

		// Preferences Management
		const preferencesManager = new PreferencesManager();

		// Helper function to apply volume
		function playSoundEffect(name, baseVolume) {
			soundManager.play(name, baseVolume * (preferencesManager.soundEffectsVolume / 100));
		}

		let backgroundSprite;

		// Initialize sound manager and music player
		const soundManager = SoundManager.init();
		const musicPlayer = new MusicPlayer();

		// Preload assets
		(async () => {
			await AssetLoader.loadAll(soundManager, musicPlayer);

			// Initialize music volume after Note class is available
			Note.setVolume(preferencesManager.musicVolume / 100);
		})();

		// Background will be tiled - store a single tile sprite
		let backgroundTileSize = new Vector2D(1536, 1024); // Actual size of background image
		backgroundSprite = new Sprite(
			'background-fuzzy-edge.png',
			new Vector2D(0, 0),
			backgroundTileSize
		);

		// Initialize game state
		const gameState = new GameState(canvas);

		// Game state management functions
		async function startGame() {
			// Resume audio context on user interaction (required by browser autoplay policies)
			await SoundManager.resumeAudioContext();

			gameState.reset();
			gameState.currentState = GameState.States.PLAYING;
			menuSystem.hideMenu();
			musicPlayer.play();
			setCursorVisibility(false);
		}

		function gameOver() {
			gameState.currentState = null; // No longer in active gameplay
			musicPlayer.stop();
			setCursorVisibility(true);
			showGameOverMenu();
		}

		function returnToMenu() {
			gameState.currentState = null; // No longer in active gameplay
			musicPlayer.stop();
			setCursorVisibility(true);
			showMainMenu();
		}

		// Menu configuration functions
		function showMainMenu() {
			setMenuOverlayMode(false); // Opaque overlay with background

			// Restore title image if it was replaced by text
			const titleElement = document.getElementById('menuTitle');
			if (!titleElement.querySelector('img')) {
				titleElement.innerHTML = '<img id="menuTitleImage" src="title.png" alt="SPACE SHOOTER" style="width: 325px; height: 28px;">';
			}

			menuSystem.showMenu(MenuSystem.MenuTypes.MAIN, {
				title: 'SPACE SHOOTER',
				items: [
					{
						type: 'button',
						label: 'New Game',
						action: () => startGame()
					},
					{
						type: 'button',
						label: 'High Scores',
						action: () => highScoreManager.showHighScoresMenu()
					},
					{
						type: 'button',
						label: 'Options',
						action: () => showOptionsMenu()
					},
					{
						type: 'button',
						label: 'Achievements',
						action: () => showAchievementsMenu()
					}
				],
				instructions: 'Arrow Keys or Left Stick: Move | Space or A Button: Shoot | ESC: Pause'
			});
		}


		function showGameOverMenu() {
			setMenuOverlayMode(false); // Opaque overlay with background

			let playerName = '';

			menuSystem.showMenu(MenuSystem.MenuTypes.GAME_OVER, {
				title: 'GAME OVER',
				items: [
					{
						type: 'textInput',
						id: 'playerNameInput',
						label: 'Enter Your Name:',
						placeholder: 'Player',
						maxLength: 15,
						autofocus: true,
						onChange: (value) => {
							playerName = value;
						}
					},
					{
						type: 'button',
						label: 'Submit Score',
						action: () => {
							const name = playerName.trim() || 'Anonymous';
							highScoreManager.saveHighScore(name, gameState.score);
							highScoreManager.showHighScoresMenu();
						}
					},
					{
						type: 'button',
						label: 'New Game',
						action: () => {
							const name = playerName.trim() || 'Anonymous';
							highScoreManager.saveHighScore(name, gameState.score);
							startGame();
						}
					},
					{
						type: 'button',
						label: 'Main Menu',
						action: () => {
							const name = playerName.trim() || 'Anonymous';
							highScoreManager.saveHighScore(name, gameState.score);
							returnToMenu();
						}
					}
				],
				instructions: `Final Score: ${gameState.score}`
			});
		}

		function pauseGame() {
			if (gameState.currentState === GameState.States.PLAYING) {
				gameState.currentState = GameState.States.PAUSED;
				musicPlayer.pause();
				canvas.classList.remove('hide-cursor');
				showPauseMenu();
			}
		}

		function resumeGame() {
			gameState.currentState = GameState.States.PLAYING;
			menuSystem.hideMenu();
			musicPlayer.play();
			setCursorVisibility(false);
		}

		function showPauseMenu() {
			setMenuOverlayMode(true); // Transparent overlay for pause

			menuSystem.showMenu(MenuSystem.MenuTypes.PAUSE, {
				title: 'PAUSED',
				items: [
					{
						type: 'button',
						label: 'Continue',
						action: () => resumeGame()
					},
					...getVolumeSliders(),
					getFullscreenCheckbox(),
					{
						type: 'button',
						label: 'Quit',
						action: () => {
							if (gameState.score > 0) {
								gameOver();
							} else {
								returnToMenu();
							}
						}
					}
				],
				instructions: ''
			});
		}

		function checkUltimateWeaponAchievement() {
			if (gameState.player.weaponLevel === 10 &&
				gameState.player.engineLevel === 10 &&
				gameState.player.shieldLevel === 10) {
				achievementManager.unlock('ultimate_weapon');
			}
		}

		function showUpgradeMenu() {
			// Set upgrading state - time passes but player has no control
			gameState.currentState = GameState.States.UPGRADING;
			musicPlayer.pause();
			setCursorVisibility(true);
			setMenuOverlayMode(true); // Transparent overlay for pause

			// Check max levels
			const maxWeaponLevel = GameConfig.UPGRADES.WEAPON.length - 1;
			const maxEngineLevel = GameConfig.UPGRADES.ENGINE.length - 1;
			const maxShieldLevel = GameConfig.UPGRADES.SHIELD.length - 1;

			const weaponMaxed = gameState.player.weaponLevel >= maxWeaponLevel;
			const engineMaxed = gameState.player.engineLevel >= maxEngineLevel;
			const shieldMaxed = gameState.player.shieldLevel >= maxShieldLevel;
			const allMaxed = weaponMaxed && engineMaxed && shieldMaxed;

			const items = [];

			if (allMaxed) {
				// All upgrades maxed - show "Heal and Continue" button
				items.push({
					type: 'button',
					label: 'Heal and Continue',
					action: () => {
						// Heal to full health
						gameState.player.health = gameState.player.maxHealth;
						DebugLogger.log(`Healed to full health: ${gameState.player.health}`);
						resumeFromUpgrade();
					}
				});
			} else {
				// Show upgrade buttons (disabled if maxed)
				items.push({
					type: 'button',
					label: weaponMaxed
						? `Weapon Upgrade (MAX LEVEL)`
						: `Weapon Upgrade (Level ${gameState.player.weaponLevel} → ${gameState.player.weaponLevel + 1})`,
					disabled: weaponMaxed,
					action: () => {
						gameState.player.weaponLevel++;
						DebugLogger.log(`Weapon upgraded to level ${gameState.player.weaponLevel}`);

						// Update weapon upgrade achievement progress
						achievementManager.setProgress('fully_armed', gameState.player.weaponLevel);
						checkUltimateWeaponAchievement();

						resumeFromUpgrade();
					}
				});

				items.push({
					type: 'button',
					label: engineMaxed
						? `Engine Upgrade (MAX LEVEL)`
						: `Engine Upgrade (Level ${gameState.player.engineLevel} → ${gameState.player.engineLevel + 1})`,
					disabled: engineMaxed,
					action: () => {
						gameState.player.engineLevel++;
						DebugLogger.log(`Engine upgraded to level ${gameState.player.engineLevel}`);

						// Update engine upgrade achievement progress
						achievementManager.setProgress('speed_demon', gameState.player.engineLevel);
						checkUltimateWeaponAchievement();

						resumeFromUpgrade();
					}
				});

				items.push({
					type: 'button',
					label: shieldMaxed
						? `Shield Upgrade (MAX LEVEL)`
						: `Shield Upgrade (Level ${gameState.player.shieldLevel} → ${gameState.player.shieldLevel + 1})`,
					disabled: shieldMaxed,
					action: () => {
						gameState.player.shieldLevel++;
						gameState.player.applyShieldUpgrade(); // Apply max health and heal to full
						DebugLogger.log(`Shield upgraded to level ${gameState.player.shieldLevel}`);

						// Update shield upgrade achievement progress
						achievementManager.setProgress('fortress', gameState.player.shieldLevel);
						checkUltimateWeaponAchievement();

						resumeFromUpgrade();
					}
				});
			}

			menuSystem.showMenu(MenuSystem.MenuTypes.UPGRADE, {
				title: allMaxed ? 'ALL UPGRADES COMPLETE' : 'CHOOSE UPGRADE',
				items: items,
				instructions: allMaxed
					? 'You have reached maximum power!'
					: 'Select one upgrade before entering the wormhole'
			});
		}

		function resumeFromUpgrade() {
			// Check Untouchable achievement before advancing
			if (gameState.achievementStats.damageTakenThisWave === 0) {
				achievementManager.unlock('untouchable');
			}

			// Resume game and advance level
			gameState.currentState = GameState.States.PLAYING;
			menuSystem.hideMenu();
			musicPlayer.play();
			setCursorVisibility(false);
			gameState.advanceLevel();

			// Update wave progression achievements
			achievementManager.setProgress('warp_speed', gameState.currentLevel);
			achievementManager.setProgress('deep_space', gameState.currentLevel);
			achievementManager.setProgress('into_the_void', gameState.currentLevel);
		}

		function showOptionsMenu() {
			setMenuOverlayMode(false); // Opaque overlay with background

			menuSystem.showMenu(MenuSystem.MenuTypes.OPTIONS, {
				title: 'OPTIONS',
				items: [
					...getVolumeSliders(),
					getFullscreenCheckbox(),
					{
						type: 'button',
						label: 'Back',
						action: () => showMainMenu()
					}
				],
				instructions: ''
			});
		}

		function showAchievementsMenu() {
			setMenuOverlayMode(false); // Opaque overlay with background

			// Build achievement list with unlock status and progress
			const achievementList = GameConfig.ACHIEVEMENTS.map(achievement => {
				return {
					...achievement,
					unlocked: achievementManager.isUnlocked(achievement.id),
					progress: achievementManager.getProgress(achievement.id)
				};
			});

			const unlockedCount = achievementManager.getUnlockedCount();
			const totalCount = achievementManager.getTotalCount();

			menuSystem.showMenu(MenuSystem.MenuTypes.ACHIEVEMENTS, {
				title: 'ACHIEVEMENTS',
				items: [
					{
						type: 'achievementList',
						achievements: achievementList,
						headerText: `${unlockedCount} / ${totalCount} Unlocked`
					},
					{
						type: 'button',
						label: 'Back',
						action: () => showMainMenu()
					}
				],
				instructions: ''
			});
		}

		// Render loop
		function render() {
			// Special rendering for upgrade menu
			if (gameState.currentState === GameState.States.UPGRADING) {
				gameState.upgradeBackground.draw(context, canvas.width, canvas.height, gameState.player.sprite.position);
				return; // Menu overlay will render on top
			}

			// Background
			context.fillStyle = 'black';
			context.fillRect(0, 0, canvas.width, canvas.height);

			context.save();
			context.translate(
				canvas.width/2-gameState.player.sprite.position.x,
				canvas.height/2-gameState.player.sprite.position.y
			);

			// Draw tiled background
			const tileWidth = backgroundTileSize.x * 0.9;
			const tileHeight = backgroundTileSize.y * 0.85;

			// Calculate which tiles are visible
			const startX = Math.floor((gameState.player.sprite.position.x - canvas.width) / tileWidth) * tileWidth;
			const startY = Math.floor((gameState.player.sprite.position.y - canvas.height) / tileHeight) * tileHeight;
			const endX = Math.ceil((gameState.player.sprite.position.x + canvas.width) / tileWidth) * tileWidth;
			const endY = Math.ceil((gameState.player.sprite.position.y + canvas.height) / tileHeight) * tileHeight;

			// Draw tiles
			context.globalCompositeOperation = 'lighten';
			for (let x = startX; x <= endX; x += tileWidth) {
				for (let y = startY; y <= endY; y += tileHeight) {
					backgroundSprite.position.x = x + tileWidth / 2;
					backgroundSprite.position.y = y + tileHeight / 2;
					backgroundSprite.draw();
				}
			}
			// Reset composition
			context.globalCompositeOperation = 'source-over';

			// Z-order: Wormhole first (bottom layer)
			if (gameState.wormhole) {
				gameState.wormhole.draw();
			}

			// Shots
			for (const projectile of gameState.playerProjectiles) {
				projectile.draw();
			}
			for (const projectile of gameState.npcProjectiles) {
				projectile.draw();
			}

			// NPCs
			for (const npc of gameState.npcs) {
				npc.draw();
			}

			// Particles
			gameState.particleSystem.draw(context);

			// Player last (top layer)
			gameState.player.draw();

			context.restore();

			// HUD - render in screen space
			// Health bar
			const healthBarWidth = gameState.player.maxHealth;
			const healthBarHeight = GameConfig.HUD.HEALTH_BAR_HEIGHT;
			const healthBarX = GameConfig.HUD.HEALTH_BAR_X;
			const healthBarY = GameConfig.HUD.HEALTH_BAR_Y;

			// Draw health bar background (red - shows damage)
			context.fillStyle = GameConfig.HUD.HEALTH_BAR_BG_COLOR;
			context.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

			// Draw health bar foreground (green - shows current health)
			const healthPercentage = Math.max(0, Math.min(1, gameState.player.health / gameState.player.maxHealth));
			const currentHealthWidth = healthBarWidth * healthPercentage;
			context.fillStyle = GameConfig.HUD.HEALTH_BAR_FG_COLOR;
			context.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

			// Draw health bar border (white)
			context.strokeStyle = GameConfig.HUD.HEALTH_BAR_BORDER_COLOR;
			context.lineWidth = GameConfig.HUD.HEALTH_BAR_BORDER_WIDTH;
			context.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

			// Draw score
			context.fillStyle = '#FFFFFF';
			context.font = '12px "Press Start 2P"';
			context.textAlign = 'left';
			context.fillText(`Score: ${gameState.score}`, 10, 60);

			// Mini-map
			gameState.minimap.draw(context, {
				npcs: gameState.npcs,
				wormhole: gameState.wormhole
			}, gameState.player.sprite.position);

			// Wormhole message and arrow
			if (gameState.wormhole) {
				// Draw message with stroke
				context.font = '16px "Press Start 2P"';
				context.textAlign = 'center';
				// Draw white stroke (outline)
				context.strokeStyle = '#000000';
				context.lineWidth = 2;
				context.strokeText('Wormhole detected!', canvas.width / 2, 50);
				// Draw cyan fill
				context.fillStyle = '#00FFFF';
				context.fillText('Wormhole detected!', canvas.width / 2, 50);

				// Calculate direction to wormhole
				const dx = gameState.wormhole.position.x - gameState.player.sprite.position.x;
				const dy = gameState.wormhole.position.y - gameState.player.sprite.position.y;
				const angle = Math.atan2(dy, dx);

				// Check if wormhole is on-screen
				const screenHalfWidth = canvas.width / 2;
				const screenHalfHeight = canvas.height / 2;
				const wormholeOnScreen = Math.abs(dx) < screenHalfWidth && Math.abs(dy) < screenHalfHeight;

				// Only draw arrow if wormhole is off-screen
				if (!wormholeOnScreen) {
					// Draw arrow at screen edge pointing to wormhole
					const arrowDistance = 50; // Distance from screen edge
					const centerX = canvas.width / 2;
					const centerY = canvas.height / 2;

					// Calculate arrow position at edge of screen
					let arrowX = centerX + Math.cos(angle) * (canvas.width / 2 - arrowDistance);
					let arrowY = centerY + Math.sin(angle) * (canvas.height / 2 - arrowDistance);

					// Clamp to screen bounds
					arrowX = Math.max(arrowDistance, Math.min(canvas.width - arrowDistance, arrowX));
					arrowY = Math.max(arrowDistance, Math.min(canvas.height - arrowDistance, arrowY));

					// Draw arrow
					context.save();
					context.translate(arrowX, arrowY);
					context.rotate(angle);
					// Draw white stroke (outline)
					context.strokeStyle = '#000000';
					context.lineWidth = 2;
					context.beginPath();
					context.moveTo(15, 0);
					context.lineTo(-10, -10);
					context.lineTo(-10, 10);
					context.closePath();
					context.stroke();
					// Draw cyan fill
					context.fillStyle = '#00FFFF';
					context.beginPath();
					context.moveTo(15, 0);
					context.lineTo(-10, -10);
					context.lineTo(-10, 10);
					context.closePath();
					context.fill();
					context.restore();
				}
			}
		}

		// Handle ESC key for pause/resume (checked every frame)
		function handlePauseInput() {
			if (engine.keyDown["Escape"]) {
				engine.keyDown["Escape"] = false;
				if (gameState.currentState === GameState.States.PLAYING) {
					pauseGame();
				} else if (gameState.currentState === GameState.States.PAUSED) {
					resumeGame();
				}
			}
		}

		// Helper: Get volume slider controls (used in Pause and Options menus)
		function getVolumeSliders() {
			return [
				{
					type: 'slider',
					label: 'Sound Effects Volume',
					min: 0,
					max: 100,
					value: preferencesManager.soundEffectsVolume,
					suffix: '%',
					onChange: (value) => {
						preferencesManager.soundEffectsVolume = parseInt(value);
					}
				},
				{
					type: 'slider',
					label: 'Music Volume',
					min: 0,
					max: 100,
					value: preferencesManager.musicVolume,
					suffix: '%',
					onChange: (value) => {
						preferencesManager.musicVolume = parseInt(value);
						Note.setVolume(preferencesManager.musicVolume / 100);
					}
				}
			];
		}

		// Helper: Get fullscreen checkbox control (used in Pause and Options menus)
		function getFullscreenCheckbox() {
			return {
				type: 'checkbox',
				label: 'Fullscreen',
				checked: VibeEngine.instance.isFullScreen,
				onChange: (checked) => {
					if (checked && !VibeEngine.instance.isFullScreen) {
						VibeEngine.instance.enterFullScreen();
					} else if (!checked && VibeEngine.instance.isFullScreen) {
						VibeEngine.instance.exitFullScreen();
					}
				}
			};
		}

		// Helper: Set cursor visibility
		function setCursorVisibility(visible) {
			if (visible) {
				canvas.classList.remove('hide-cursor');
			} else {
				canvas.classList.add('hide-cursor');
			}
		}

		// Helper: Set menu overlay mode (pause = transparent overlay, regular = opaque)
		function setMenuOverlayMode(isPauseMode) {
			const overlay = document.getElementById('menuOverlay');
			if (isPauseMode) {
				overlay.classList.add('pause');
			} else {
				overlay.classList.remove('pause');
			}
		}

		// Helper: Update all projectiles
		function updateAllProjectiles() {
			for (const projectile of gameState.playerProjectiles) {
				projectile.update();
			}
			for (const projectile of gameState.npcProjectiles) {
				projectile.update();
			}
		}

		// Helper: Despawn projectiles that are too far from player
		function despawnDistantProjectiles(despawnDistance) {
			const filterByDistance = (projectile) => {
				const distance = projectile.sprite.position.dist(gameState.player.sprite.position);
				return distance < despawnDistance;
			};
			gameState.playerProjectiles = gameState.playerProjectiles.filter(filterByDistance);
			gameState.npcProjectiles = gameState.npcProjectiles.filter(filterByDistance);
		}

		// Helper: Wrap a single coordinate around world boundaries
		function wrapCoordinate(npcCoord, playerCoord, wrapDistance) {
			const offset = npcCoord - playerCoord;
			if (offset > wrapDistance) {
				return playerCoord - wrapDistance;
			} else if (offset < -wrapDistance) {
				return playerCoord + wrapDistance;
			}
			return npcCoord;
		}

		// Player shooting function
		function shoot() {
			const weaponStats = gameState.player.getWeaponStats();
			const spreadRadians = weaponStats.spreadAngle * (Math.PI / 180);
			const shotPosition = new Vector2D(
				gameState.player.sprite.position.x,
				gameState.player.sprite.position.y
			);

			// Determine which weapon types are ready to fire
			const weaponTypesReady = new Set();
			for (let i = 0; i < weaponStats.projectileTypes.length; i++) {
				const projectileType = weaponStats.projectileTypes[i];

				// Calculate cooldown multiplier: missiles fire at half rate (2x cooldown)
				let cooldownMultiplier = 1;
				if (projectileType === 'missile') {
					cooldownMultiplier = 3;
				}
				const effectiveCooldown = weaponStats.fireRate * cooldownMultiplier;

				// Check if this weapon type is ready to fire
				if (gameState.gameTime > gameState.lastShotTime[projectileType] + effectiveCooldown) {
					weaponTypesReady.add(projectileType);
				}
			}

			// Fire all weapon slots whose types are ready
			if (weaponTypesReady.size > 0) {
				for (let i = 0; i < weaponStats.projectileTypes.length; i++) {
					const projectileType = weaponStats.projectileTypes[i];

					// Only fire if this weapon type is ready
					if (weaponTypesReady.has(projectileType)) {
						// Calculate angle for this shot
						let shotAngle = gameState.player.sprite.rotation;
						if (weaponStats.projectileTypes.length > 1) {
							// Distribute shots evenly across the spread angle
							const angleOffset = (i - (weaponStats.projectileTypes.length - 1) / 2) * spreadRadians;
							shotAngle += angleOffset;
						}

						// Create the appropriate projectile
						let newShot;
						if (projectileType === 'plasma') {
							const shotVelocity = Vector2D.fromRadial(shotAngle, Plasma.speed);
							newShot = new Plasma(shotPosition, shotVelocity);
						} else if (projectileType === 'missile') {
							const shotVelocity = Vector2D.fromRadial(shotAngle, Missile.speed);
							newShot = new Missile(shotPosition, shotVelocity);
						} else if (projectileType === 'laser') {
							const shotVelocity = Vector2D.fromRadial(shotAngle, Laser.speed);
							newShot = new Laser(shotPosition, shotVelocity);
						} else {
							DebugLogger.log(`Unexpected projectileType: ${projectileType}`);
						}

						gameState.playerProjectiles.push(newShot);
					}
				}

				// Update last shot time for all weapon types that fired
				for (const weaponType of weaponTypesReady) {
					gameState.lastShotTime[weaponType] = gameState.gameTime;
				}

				// Play sound
				playSoundEffect('shoot', 0.3);
			}
		}

		// Update loop; deltaTime is milliseconds
		function update(deltaTime) {
			// Handle pause input regardless of game state
			handlePauseInput();

			// Update upgrade background animation if in upgrading state
			if (gameState.currentState === GameState.States.UPGRADING) {
				gameState.upgradeBackground.update(deltaTime);
				gameState.gameTime += deltaTime; // Time passes during upgrade menu
				return;
			}

			// Only update game logic during active gameplay
			if (gameState.currentState !== GameState.States.PLAYING) {
				return;
			}
			// Accumulate game time (only advances during gameplay, not when paused)
			gameState.gameTime += deltaTime;

			if (engine.keyDown["ArrowLeft"]) {
				gameState.player.turnLeft(deltaTime);
			}
			if (engine.keyDown["ArrowRight"]) {
				gameState.player.turnRight(deltaTime);
			}
			if (engine.keyDown["ArrowUp"]) {
				gameState.player.accelerate(deltaTime);
			}
			if (engine.keyDown["ArrowDown"]) {
				gameState.player.reverseThrust(deltaTime);
			}
			if (engine.keyDown[" "]) {
				shoot();
			}

			gameState.player.update(deltaTime);
			gameState.player.updateShieldRegen(deltaTime); // Update shield regeneration

			// Update all NPCs with unified loop
			for (const npc of gameState.npcs) {
				// All NPCs accept playerPosition (asteroids ignore it)
				npc.update(deltaTime, gameState.player.sprite.position);

				// Handle NPC shooting (unified)
				if (npc.tryShoot) {
					const shootResult = npc.tryShoot(gameState.gameTime);
					if (shootResult && shootResult.shots) {
						gameState.npcProjectiles.push(...shootResult.shots);
						if (shootResult.sound) {
							playSoundEffect(shootResult.sound, shootResult.volume);
						}
					}
				}
			}

			// Update all projectiles
			updateAllProjectiles();

			// Update particles
			gameState.particleSystem.update(deltaTime);

			// Update wormhole if it exists
			if (gameState.wormhole) {
				gameState.wormhole.update(deltaTime);
				gameState.wormhole.wrap(gameState.player.sprite.position);
			}

			// Wave-based spawning: Spawn wormhole when wave cleared
			gameState.trySpawnWormhole();

			// Collision detection
			const npcsToRemove = new Set();
			const playerProjectilesToRemove = new Set();
			const npcProjectilesToRemove = new Set();

			// Check player shot collisions with all NPCs (unified loop)
			for (const shot of gameState.playerProjectiles) {
				for (const npc of gameState.npcs) {
					if (CollisionDetection.checkAABB(shot, npc)) {
						playerProjectilesToRemove.add(shot);

						// Spawn impact particles and sound from shot properties
						if (shot.particleColor) {
							gameState.particleSystem.spawnImpact(shot.sprite.position, shot.particleColor);
						}
						if (shot.hitSound) {
							playSoundEffect(shot.hitSound, shot.hitVolume);
						}

						// Check if NPC is offscreen for Sniper achievement
						const npcScreenX = npc.sprite.position.x - gameState.player.sprite.position.x + canvas.width / 2;
						const npcScreenY = npc.sprite.position.y - gameState.player.sprite.position.y + canvas.height / 2;
						const isOffscreen = npcScreenX < 0 || npcScreenX > canvas.width ||
						                    npcScreenY < 0 || npcScreenY > canvas.height;

						if (isOffscreen) {
							achievementManager.unlock('sniper');
						}

						DebugLogger.log(`Shot damage: ${shot.damage}, NPC type: ${npc.constructor.name}, NPC health before: ${npc.health}`);
						const hitResult = npc.onHit(shot.damage);
						DebugLogger.log(`Hit result destroyed: ${hitResult.destroyed}, NPC health after: ${npc.health}`);
						if (hitResult.destroyed) {
							npcsToRemove.add(npc);
							gameState.score += npc.scoreValue;
							gameState.particleSystem.spawnExplosion(npc.sprite.position, hitResult.particleColor);
							if (hitResult.spawns) {
								gameState.npcs.push(...hitResult.spawns);
							}

							// Track alien kills (not asteroids) for centurion achievement
							if (npc.constructor.name !== 'Asteroid' && npc.constructor.name !== 'AsteroidSpawn') {
								achievementManager.progress('centurion', 1);
							}
						}
						if (hitResult.sound) {
							playSoundEffect(hitResult.sound, hitResult.volume);
						}
					}
				}
			}

			// Check player-NPC collisions (unified loop)
			for (const npc of gameState.npcs) {
				if (CollisionDetection.checkAABB(gameState.player, npc)) {
					npcsToRemove.add(npc);

					const collisionResult = npc.onCollideWithPlayer();
					DebugLogger.log(`Player-NPC collision! NPC type: ${npc.constructor.name}, NPC health: ${npc.health}, collision damage: ${collisionResult.damage}, player health before: ${gameState.player.health}`);
					gameState.particleSystem.spawnExplosion(npc.sprite.position, collisionResult.particleColor);
					gameState.player.health -= collisionResult.damage;
					gameState.player.onDamage(); // Reset shield regen timer
					DebugLogger.log(`Player health after: ${gameState.player.health}`);
					if (collisionResult.sound) {
						playSoundEffect(collisionResult.sound, collisionResult.volume);
					}

					// Track collision kills for demolition_derby achievement
					achievementManager.progress('demolition_derby', 1);

					// Track damage taken for untouchable achievement
					gameState.achievementStats.damageTakenThisWave += collisionResult.damage;
				}
			}

			// Check NPC projectile-player collisions (unified loop)
			for (const projectile of gameState.npcProjectiles) {
				if (CollisionDetection.checkAABB(gameState.player, projectile)) {
					npcProjectilesToRemove.add(projectile);

					const hitResult = projectile.onHitPlayer();
					gameState.player.health -= hitResult.damage;
					gameState.player.onDamage(); // Reset shield regen timer
					DebugLogger.log(`Player hit by projectile! Health: ${gameState.player.health}`);

					if (hitResult.sound) {
						playSoundEffect(hitResult.sound, hitResult.volume);
					}

					if (hitResult.particleColor) {
						gameState.particleSystem.spawnExplosion(projectile.sprite.position, hitResult.particleColor);
					}

					// Track damage taken for untouchable achievement
					gameState.achievementStats.damageTakenThisWave += hitResult.damage;
				}
			}

			// Check player-wormhole collision (show upgrade menu)
			if (gameState.wormhole && CollisionDetection.checkCircle(gameState.wormhole, gameState.player)) {
				showUpgradeMenu();
				playSoundEffect('achievement', 0.5); // Play a sound effect
			}

			// Remove collided entities (unified filtering)
			gameState.npcs = gameState.npcs.filter(npc => !npcsToRemove.has(npc));
			gameState.playerProjectiles = gameState.playerProjectiles.filter(projectile => !playerProjectilesToRemove.has(projectile));
			gameState.npcProjectiles = gameState.npcProjectiles.filter(projectile => !npcProjectilesToRemove.has(projectile));

			// Check for game over
			if (gameState.player.health <= 0) {
				gameOver();
				return;
			}

			// Wrap NPCs that go beyond minimap bounds, despawn projectiles
			const wrapDistance = GameConfig.WORLD.NPC_WRAP_DISTANCE; // Minimap range - wrap NPCs at this distance
			const despawnDistance = Math.max(canvas.width, canvas.height) * GameConfig.WORLD.PROJECTILE_DESPAWN_MULTIPLIER; // Despawn projectiles

			// Wrap all NPCs around minimap edges
			for (const npc of gameState.npcs) {
				npc.sprite.position.x = wrapCoordinate(npc.sprite.position.x, gameState.player.sprite.position.x, wrapDistance);
				npc.sprite.position.y = wrapCoordinate(npc.sprite.position.y, gameState.player.sprite.position.y, wrapDistance);
			}

			// Despawn projectiles that are too far from player
			despawnDistantProjectiles(despawnDistance);

			checkGamepadInput(deltaTime);
		}

		function checkGamepadInput(deltaTime) {
			const gamepads = navigator.getGamepads();
			const deadzone = GameConfig.PLAYER.GAMEPAD_DEADZONE; // Ignore small stick movements to prevent drift

			for (const gamepad of gamepads) {
				if (!gamepad) continue;

				// Left stick horizontal (axis 0): Turn left/right
				const leftStickX = gamepad.axes[0];
				if (Math.abs(leftStickX) > deadzone) {
					if (leftStickX < 0) {
						gameState.player.turnLeft(deltaTime * Math.abs(leftStickX));
					} else {
						gameState.player.turnRight(deltaTime * leftStickX);
					}
				}

				// Right stick vertical (axis 3) or triggers for thrust
				const rightStickY = gamepad.axes[3];
				if (rightStickY < -deadzone) {
					// Right stick pushed up: forward thrust
					gameState.player.accelerate(deltaTime * Math.abs(rightStickY));
				} else if (rightStickY > deadzone) {
					// Right stick pulled down: reverse thrust
					gameState.player.reverseThrust(deltaTime * rightStickY);
				}

				// Button 7 (RT/R2): Forward thrust
				if (gamepad.buttons[7] && gamepad.buttons[7].pressed) {
					const triggerValue = gamepad.buttons[7].value || 1.0;
					gameState.player.accelerate(deltaTime * triggerValue);
				}

				// Button 6 (LT/L2): Reverse thrust
				if (gamepad.buttons[6] && gamepad.buttons[6].pressed) {
					const triggerValue = gamepad.buttons[6].value || 1.0;
					gameState.player.reverseThrust(deltaTime * triggerValue);
				}

				// Button 0 (A/Cross): Shoot
				if (gamepad.buttons[0] && gamepad.buttons[0].pressed) {
					shoot();
				}

				// Button 9 (Start/Options): Pause game
				if (gamepad.buttons[9] && gamepad.buttons[9].pressed) {
					// Debounce by checking if button was just pressed
					if (!gamepad.buttons[9].wasPressed) {
						pauseGame();
						gamepad.buttons[9].wasPressed = true;
					}
				} else if (gamepad.buttons[9]) {
					gamepad.buttons[9].wasPressed = false;
				}
			}
		}

		// Show main menu and start game loop
		showMainMenu();
		engine.start(update, render, () => Sprite.stillLoading());
	</script>
</body>
</html>