<!-- A basic 2D HTML + JavaScript game engine, consisting of:
1. Canvas element, 800x600
2. Render loop
3. Update loop
4. Global data for current mouse position, stored as vector class
 -->

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Retro Space Shooter</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link id="css" rel="stylesheet" href="css.css"/ >
	<script type="text/javascript" src="DebugLogger.js"></script>
	<script>
		// Enable debug logging only when running on localhost
		DebugLogger.debug = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
	</script>
	<script type="text/javascript" src="GameConfig.js"></script>
	<script type="text/javascript" src="AssetLoader.js"></script>
	<script type="text/javascript" src="CollisionDetection.js"></script>
	<script type="text/javascript" src="VibeEngine.js"></script>
	<script type="text/javascript" src="Vector2D.js"></script>
	<script type="text/javascript" src="Particle.js"></script>
	<script type="text/javascript" src="ParticleSystem.js"></script>
	<script type="text/javascript" src="NPCAIUtils.js"></script>
	<script type="text/javascript" src="SpawnSystem.js"></script>
	<script type="text/javascript" src="GameState.js"></script>
    <script type="text/javascript" src="GameEntity.js"></script>
	<script type="text/javascript" src="Sprite.js"></script>
	<script type="text/javascript" src="NPC.js"></script>
	<script type="text/javascript" src="AlienScout.js"></script>
	<script type="text/javascript" src="AlienFighter.js"></script>
	<script type="text/javascript" src="Asteroid.js"></script>
	<script type="text/javascript" src="AsteroidSpawn.js"></script>
	<script type="text/javascript" src="Wormhole.js"></script>
	<script type="text/javascript" src="UpgradeBackground.js"></script>
	<script type="text/javascript" src="Projectile.js"></script>
	<script type="text/javascript" src="Laser.js"></script>
	<script type="text/javascript" src="Plasma.js"></script>
	<script type="text/javascript" src="Missile.js"></script>
	<script type="text/javascript" src="MissileCruiser.js"></script>
	<script type="text/javascript" src="AlienSaucer.js"></script>
	<script type="text/javascript" src="Player.js"></script>
	<script type="text/javascript" src="SoundManager.js"></script>
	<script type="text/javascript" src="SimpleMusic.js"></script>
	<script type="text/javascript" src="MusicPlayer.js"></script>
	<script type="text/javascript" src="MenuSystem.js"></script>
	<script type="text/javascript" src="PreferencesManager.js"></script>
	<script type="text/javascript" src="HighScoreManager.js"></script>
	<script type="text/javascript" src="AchievementManager.js"></script>
	<script type="text/javascript" src="Minimap.js"></script>
	<script type="text/javascript" src="Game.js"></script>
</head>
<body>
	<div id="gameContainer">
		<canvas id="gameCanvas" width="800" height="600"></canvas>
		<div id="menuOverlay">
			<div class="menu-title" id="menuTitle">
				<img id="menuTitleImage" src="title.png" alt="SPACE SHOOTER" style="width: 325px; height: 28px;">
			</div>
			<div class="menu-buttons" id="menuButtons"></div>
			<div class="menu-instructions" id="menuInstructions"></div>
		</div>
	</div>
	<script type="text/javascript">
		const canvasName = "gameCanvas";
		// Get the canvas element
		const canvas = document.getElementById(canvasName);
		// Get the 2D context
		const context = canvas.getContext("2d");
		
		const engine = VibeEngine.begin(document, canvasName);
		Sprite.begin(context);

		// Initialize menu system
		const menuSystem = new MenuSystem(
			document.getElementById('menuOverlay'),
			document.getElementById('menuTitle'),
			document.getElementById('menuButtons'),
			document.getElementById('menuInstructions')
		);

		// Initialize high score manager
		const highScoreManager = new HighScoreManager(menuSystem);

		// Initialize achievement manager
		const achievementManager = new AchievementManager(menuSystem);

		// Preferences Management
		const preferencesManager = new PreferencesManager();

		// Initialize sound manager and music player
		const soundManager = SoundManager.init();
		const musicPlayer = new MusicPlayer();

		// Preload assets
		(async () => {
			await AssetLoader.loadAll(soundManager, musicPlayer);

			// Initialize music volume after Note class is available
			Note.setVolume(preferencesManager.musicVolume / 100);
		})();

		// Initialize game instance
		const game = new Game(canvas, context, menuSystem, soundManager, musicPlayer, preferencesManager, achievementManager);

		// Background will be tiled - store a single tile sprite
		const backgroundTileSize = new Vector2D(1536, 1024); // Actual size of background image
		game.backgroundSprite = new Sprite(
			'background-fuzzy-edge.png',
			new Vector2D(0, 0),
			backgroundTileSize
		);
		game.backgroundTileSize = backgroundTileSize;

		// Keep gameState reference for existing code (to be refactored later)
		const gameState = game.gameState;
		let backgroundSprite = game.backgroundSprite;

		// Helper function to apply volume
		function playSoundEffect(name, baseVolume) {
			soundManager.play(name, baseVolume * (preferencesManager.soundEffectsVolume / 100));
		}

		// Helper function for cursor visibility
		function setCursorVisibility(visible) {
			game.setCursorVisibility(visible);
		}

		// Game state management functions
		async function startGame() {
			// Resume audio context on user interaction (required by browser autoplay policies)
			await SoundManager.resumeAudioContext();
			await game.startGame();
		}

		function gameOver() {
			game.gameOver();
			showGameOverMenu();
		}

		function returnToMenu() {
			game.gameState.currentState = null; // No longer in active gameplay
			// Don't stop music - keep playing in menus
			setCursorVisibility(true);
			showMainMenu();
		}

		// Menu configuration functions
		function showMainMenu() {
			setMenuOverlayMode(false); // Opaque overlay with background

			// Start music if not already playing
			if (!musicPlayer.isPlaying) {
				musicPlayer.play();
			}

			// Restore title image if it was replaced by text
			const titleElement = document.getElementById('menuTitle');
			if (!titleElement.querySelector('img')) {
				titleElement.innerHTML = '<img id="menuTitleImage" src="title.png" alt="SPACE SHOOTER" style="width: 325px; height: 28px;">';
			}

			menuSystem.showMenu(MenuSystem.MenuTypes.MAIN, {
				title: 'SPACE SHOOTER',
				items: [
					{
						type: 'button',
						label: 'New Game',
						action: () => startGame()
					},
					{
						type: 'button',
						label: 'High Scores',
						action: () => highScoreManager.showHighScoresMenu()
					},
					{
						type: 'button',
						label: 'Options',
						action: () => showOptionsMenu()
					},
					{
						type: 'button',
						label: 'Achievements',
						action: () => showAchievementsMenu()
					}
				],
				instructions: 'Arrow Keys or Left Stick: Move | Space or A Button: Shoot | ESC: Pause'
			});
		}


		function showGameOverMenu() {
			setMenuOverlayMode(true); // Transparent overlay - show game behind

			let playerName = '';

			// Helper to save score and stop game (shared by all buttons)
			const saveAndStopGame = () => {
				const name = playerName.trim() || 'Anonymous';
				highScoreManager.saveHighScore(name, game.gameState.score);
				// Stop game from continuing to update
				game.gameState.currentState = null;
			};

			// Function to submit the score (shared between button and Enter key)
			const submitScore = () => {
				saveAndStopGame();
				highScoreManager.showHighScoresMenu();
			};

			menuSystem.showMenu(MenuSystem.MenuTypes.GAME_OVER, {
				title: 'GAME OVER',
				items: [
					{
						type: 'textInput',
						id: 'playerNameInput',
						label: 'Enter Your Name:',
						placeholder: 'Player',
						maxLength: 15,
						autofocus: true,
						onChange: (value) => {
							playerName = value;
						},
						onSubmit: submitScore
					},
					{
						type: 'button',
						label: 'Submit Score',
						action: submitScore
					},
					{
						type: 'button',
						label: 'New Game',
						action: () => {
							saveAndStopGame();
							startGame();
						}
					},
					{
						type: 'button',
						label: 'Main Menu',
						action: () => {
							saveAndStopGame();
							returnToMenu();
						}
					}
				],
				instructions: `Final Score: ${game.gameState.score}`
			});
		}

		function pauseGame() {
			if (game.gameState.currentState === GameState.States.PLAYING) {
				game.gameState.currentState = GameState.States.PAUSED;
				musicPlayer.pause();
				canvas.classList.remove('hide-cursor');
				showPauseMenu();
			}
		}

		function resumeGame() {
			game.gameState.currentState = GameState.States.PLAYING;
			menuSystem.hideMenu();
			musicPlayer.play();
			setCursorVisibility(false);
		}

		function showPauseMenu() {
			setMenuOverlayMode(true); // Transparent overlay for pause

			menuSystem.showMenu(MenuSystem.MenuTypes.PAUSE, {
				title: 'PAUSED',
				items: [
					{
						type: 'button',
						label: 'Continue',
						action: () => resumeGame()
					},
					...getVolumeSliders(),
					getFullscreenCheckbox(),
					{
						type: 'button',
						label: 'Quit',
						action: () => {
							if (game.gameState.score > 0) {
								gameOver();
							} else {
								returnToMenu();
							}
						}
					}
				],
				instructions: ''
			});
		}

		function checkUltimateWeaponAchievement() {
			if (game.gameState.player.weaponLevel === 10 &&
				game.gameState.player.engineLevel === 10 &&
				game.gameState.player.shieldLevel === 10) {
				achievementManager.unlock('ultimate_weapon');
			}
		}

		// Helper: Create an upgrade button with consistent structure
		function createUpgradeButton(upgradeName, levelProperty, achievementId, maxLevel, applyUpgrade = null) {
			const currentLevel = gameState.player[levelProperty];
			const isMaxed = currentLevel >= maxLevel;

			return {
				type: 'button',
				label: isMaxed
					? `${upgradeName} Upgrade (MAX LEVEL)`
					: `${upgradeName} Upgrade (Level ${currentLevel} â†’ ${currentLevel + 1})`,
				disabled: isMaxed,
				action: () => {
					gameState.player[levelProperty]++;
					if (applyUpgrade) applyUpgrade();
					DebugLogger.log(`${upgradeName} upgraded to level ${gameState.player[levelProperty]}`);

					// Update achievement progress
					achievementManager.setProgress(achievementId, gameState.player[levelProperty]);
					checkUltimateWeaponAchievement();

					resumeFromUpgrade();
				}
			};
		}

		function showUpgradeMenu() {
			// Check Untouchable achievement before advancing
			if (gameState.achievementStats.damageTakenThisWave === 0) {
				achievementManager.unlock('untouchable');
			}

			// Set upgrading state - time passes but player has no control
			gameState.currentState = GameState.States.UPGRADING;
			musicPlayer.pause();
			setCursorVisibility(true);
			setMenuOverlayMode(true); // Transparent overlay for pause

			// Check max levels
			const maxWeaponLevel = GameConfig.UPGRADES.WEAPON.length - 1;
			const maxEngineLevel = GameConfig.UPGRADES.ENGINE.length - 1;
			const maxShieldLevel = GameConfig.UPGRADES.SHIELD.length - 1;
			const allMaxed = gameState.player.weaponLevel >= maxWeaponLevel &&
			                 gameState.player.engineLevel >= maxEngineLevel &&
			                 gameState.player.shieldLevel >= maxShieldLevel;

			const items = [];

			if (allMaxed) {
				// All upgrades maxed - show "Heal and Continue" button
				items.push({
					type: 'button',
					label: 'Heal and Continue',
					action: () => {
						// Heal to full health
						gameState.player.health = gameState.player.maxHealth;
						DebugLogger.log(`Healed to full health: ${gameState.player.health}`);
						resumeFromUpgrade();
					}
				});
			} else {
				// Show upgrade buttons (disabled if maxed)
				items.push(createUpgradeButton('Weapon', 'weaponLevel', 'fully_armed', maxWeaponLevel));
				items.push(createUpgradeButton('Engine', 'engineLevel', 'speed_demon', maxEngineLevel));
				items.push(createUpgradeButton('Shield', 'shieldLevel', 'fortress', maxShieldLevel,
					() => gameState.player.applyShieldUpgrade()
				));
			}

			menuSystem.showMenu(MenuSystem.MenuTypes.UPGRADE, {
				title: allMaxed ? 'ALL UPGRADES COMPLETE' : 'CHOOSE UPGRADE',
				items: items,
				instructions: allMaxed
					? 'You have reached maximum power!'
					: 'Select one upgrade before entering the wormhole'
			});
		}

		function resumeFromUpgrade() {
			// Resume game and advance level
			gameState.currentState = GameState.States.PLAYING;
			menuSystem.hideMenu();
			musicPlayer.play();
			setCursorVisibility(false);
			gameState.advanceLevel();

			// Update wave progression achievements
			achievementManager.setProgress('warp_speed', gameState.currentLevel);
			achievementManager.setProgress('deep_space', gameState.currentLevel);
			achievementManager.setProgress('into_the_void', gameState.currentLevel);
		}

		function showOptionsMenu() {
			setMenuOverlayMode(false); // Opaque overlay with background

			menuSystem.showMenu(MenuSystem.MenuTypes.OPTIONS, {
				title: 'OPTIONS',
				items: [
					...getVolumeSliders(),
					getFullscreenCheckbox(),
					{
						type: 'button',
						label: 'Back',
						action: () => showMainMenu()
					}
				],
				instructions: ''
			});
		}

		function showAchievementsMenu() {
			setMenuOverlayMode(false); // Opaque overlay with background

			// Build achievement list with unlock status and progress
			const achievementList = GameConfig.ACHIEVEMENTS.map(achievement => {
				return {
					...achievement,
					unlocked: achievementManager.isUnlocked(achievement.id),
					progress: achievementManager.getProgress(achievement.id)
				};
			});

			const unlockedCount = achievementManager.getUnlockedCount();
			const totalCount = achievementManager.getTotalCount();

			menuSystem.showMenu(MenuSystem.MenuTypes.ACHIEVEMENTS, {
				title: 'ACHIEVEMENTS',
				items: [
					{
						type: 'achievementList',
						achievements: achievementList,
						headerText: `${unlockedCount} / ${totalCount} Unlocked`
					},
					{
						type: 'button',
						label: 'Back',
						action: () => showMainMenu()
					}
				],
				instructions: ''
			});
		}

		// Render loop
		function render() {
			game.render();
		}


		// Handle ESC key for pause/resume (checked every frame)
		function handlePauseInput() {
			if (engine.keyDown["Escape"]) {
				engine.keyDown["Escape"] = false;
				if (gameState.currentState === GameState.States.PLAYING) {
					pauseGame();
				} else if (gameState.currentState === GameState.States.PAUSED) {
					resumeGame();
				}
			}
		}

		// Helper: Get volume slider controls (used in Pause and Options menus)
		function getVolumeSliders() {
			return [
				{
					type: 'slider',
					label: 'Sound Effects Volume',
					min: 0,
					max: 100,
					value: preferencesManager.soundEffectsVolume,
					suffix: '%',
					onChange: (value) => {
						preferencesManager.soundEffectsVolume = parseInt(value);
					}
				},
				{
					type: 'slider',
					label: 'Music Volume',
					min: 0,
					max: 100,
					value: preferencesManager.musicVolume,
					suffix: '%',
					onChange: (value) => {
						preferencesManager.musicVolume = parseInt(value);
						Note.setVolume(preferencesManager.musicVolume / 100);
					}
				}
			];
		}

		// Helper: Get fullscreen checkbox control (used in Pause and Options menus)
		function getFullscreenCheckbox() {
			return {
				type: 'checkbox',
				label: 'Fullscreen',
				checked: VibeEngine.instance.isFullScreen,
				onChange: (checked) => {
					if (checked && !VibeEngine.instance.isFullScreen) {
						VibeEngine.instance.enterFullScreen();
					} else if (!checked && VibeEngine.instance.isFullScreen) {
						VibeEngine.instance.exitFullScreen();
					}
				}
			};
		}

		// Helper: Set cursor visibility
		function setCursorVisibility(visible) {
			if (visible) {
				canvas.classList.remove('hide-cursor');
			} else {
				canvas.classList.add('hide-cursor');
			}
		}

		// Helper: Set menu overlay mode (pause = transparent overlay, regular = opaque)
		function setMenuOverlayMode(isPauseMode) {
			const overlay = document.getElementById('menuOverlay');
			if (isPauseMode) {
				overlay.classList.add('pause');
			} else {
				overlay.classList.remove('pause');
			}
		}

		// Helper: Update all projectiles
		function updateAllProjectiles() {
			for (const projectile of gameState.playerProjectiles) {
				projectile.update();
			}
			for (const projectile of gameState.npcProjectiles) {
				projectile.update();
			}
		}

		// Helper: Check if entity is beyond wrap distance from player (per-axis check)
		function isBeyondWrapDistance(entityPos, playerPos, wrapDistance) {
			const offsetX = entityPos.x - playerPos.x;
			const offsetY = entityPos.y - playerPos.y;
			return Math.abs(offsetX) > wrapDistance || Math.abs(offsetY) > wrapDistance;
		}

		// Helper: Despawn projectiles that are too far from player (uses same logic as NPC wrapping)
		function despawnDistantProjectiles(despawnDistance) {
			gameState.playerProjectiles = gameState.playerProjectiles.filter(projectile =>
				!isBeyondWrapDistance(projectile.sprite.position, gameState.player.sprite.position, despawnDistance)
			);
			gameState.npcProjectiles = gameState.npcProjectiles.filter(projectile =>
				!isBeyondWrapDistance(projectile.sprite.position, gameState.player.sprite.position, despawnDistance)
			);
		}

		// Helper: Wrap a single coordinate around world boundaries
		function wrapCoordinate(npcCoord, playerCoord, wrapDistance) {
			const offset = npcCoord - playerCoord;
			if (offset > wrapDistance) {
				return playerCoord - wrapDistance + (offset - wrapDistance);
			} else if (offset < -wrapDistance) {
				return playerCoord + wrapDistance + (offset + wrapDistance);
			}
			return npcCoord;
		}

		// Player shooting function
		function shoot() {
			const weaponStats = gameState.player.getWeaponStats();
			const spreadRadians = weaponStats.spreadAngle * (Math.PI / 180);
			const shotPosition = new Vector2D(
				gameState.player.sprite.position.x,
				gameState.player.sprite.position.y
			);

			// Determine which weapon types are ready to fire
			const weaponTypesReady = new Set();
			for (let i = 0; i < weaponStats.projectileTypes.length; i++) {
				const projectileType = weaponStats.projectileTypes[i];

				// Calculate cooldown multiplier: missiles fire at half rate (2x cooldown)
				let cooldownMultiplier = 1;
				if (projectileType === 'missile') {
					cooldownMultiplier = 3;
				}
				const effectiveCooldown = weaponStats.fireRate * cooldownMultiplier;

				// Check if this weapon type is ready to fire
				if (gameState.gameTime > gameState.lastShotTime[projectileType] + effectiveCooldown) {
					weaponTypesReady.add(projectileType);
				}
			}

			// Fire all weapon slots whose types are ready
			if (weaponTypesReady.size > 0) {
				for (let i = 0; i < weaponStats.projectileTypes.length; i++) {
					const projectileType = weaponStats.projectileTypes[i];

					// Only fire if this weapon type is ready
					if (weaponTypesReady.has(projectileType)) {
						// Calculate angle for this shot
						let shotAngle = gameState.player.sprite.rotation;
						if (weaponStats.projectileTypes.length > 1) {
							// Distribute shots evenly across the spread angle
							const angleOffset = (i - (weaponStats.projectileTypes.length - 1) / 2) * spreadRadians;
							shotAngle += angleOffset;
						}

						// Create the appropriate projectile
						let newShot;
						if (projectileType === 'plasma') {
							const shotVelocity = Vector2D.fromRadial(shotAngle, Plasma.speed);
							newShot = new Plasma(shotPosition, shotVelocity);
						} else if (projectileType === 'missile') {
							const shotVelocity = Vector2D.fromRadial(shotAngle, Missile.speed);
							newShot = new Missile(shotPosition, shotVelocity);
						} else if (projectileType === 'laser') {
							const shotVelocity = Vector2D.fromRadial(shotAngle, Laser.speed);
							newShot = new Laser(shotPosition, shotVelocity);
						} else {
							DebugLogger.log(`Unexpected projectileType: ${projectileType}`);
						}

						gameState.playerProjectiles.push(newShot);
					}
				}

				// Update last shot time for all weapon types that fired
				for (const weaponType of weaponTypesReady) {
					gameState.lastShotTime[weaponType] = gameState.gameTime;
				}

				// Play sound
				playSoundEffect('shoot', 0.3);
			}
		}


		// Update loop; deltaTime is milliseconds
		function update(deltaTime) {
			// Handle pause input regardless of game state
			handlePauseInput();

			// Handle upgrade background animation if in upgrading state
			if (gameState.currentState === GameState.States.UPGRADING) {
				gameState.upgradeBackground.update(deltaTime);
			}

			// Delegate to game for actual game logic
			const result = game.update(deltaTime, engine);

			// Handle menu state transitions
			if (result) {
				if (result.gameOver) {
					gameOver();
				} else if (result.wormholeCollision) {
					showUpgradeMenu();
				}
			}
		}


		// Show main menu and start game loop
		showMainMenu();
		engine.start(update, render, () => Sprite.stillLoading());
	</script>
</body>
</html>